<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<?asciidoc-toc?>
<?asciidoc-numbered?>

<article lang="en">
<articleinfo>
    <title>Introduction</title>
</articleinfo>
<blockquote>
<simpara>“I am two with nature.”
        —Woody Allen</simpara>
</blockquote>
<simpara>Here we are: the beginning.  Well, almost the beginning. If it’s been a while since you’ve done any programming in Processing (or any math, for that matter), this introduction will get your mind back into computational thinking before we head into some of the more difficult and complex material.</simpara>
<simpara>In Chapter 1, we’re going to talk about the concept of a vector and how it will serve as the building block for simulating motion throughout this book.   But before we take that step, let’s think about what it means for something to simply move around the screen.   Let’s begin with one of the best-known and simplest simulations of motion—the Random Walk.</simpara>
<section id="_random_walks">
<title>Random Walks</title>
<simpara>Imagine you are standing in the middle of a balance beam.  Every ten seconds, you flip a coin.  Heads, take a step forward.  Tails, take a step backwards.   This is a random walk—a path defined as a series of random steps.    Stepping off that balance beam and onto the floor, you could perform a random walk in two dimensions by flipping that same coin twice with the following results:</simpara>
<informaltable
frame="all"
rowsep="1" colsep="1"
>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top">Flip 1 </entry>
<entry align="left" valign="top">Flip 2 </entry>
<entry align="left" valign="top">Result</entry>
</row>
</thead>
<tfoot>
<row>
<entry align="left" valign="top"><simpara>Tails</simpara></entry>
<entry align="left" valign="top"><simpara>Tails</simpara></entry>
<entry align="left" valign="top"><simpara>Step backward.</simpara></entry>
</row>
</tfoot>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Heads</simpara></entry>
<entry align="left" valign="top"><simpara>Heads</simpara></entry>
<entry align="left" valign="top"><simpara>Step forward.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Heads</simpara></entry>
<entry align="left" valign="top"><simpara>Tails</simpara></entry>
<entry align="left" valign="top"><simpara>Step right.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Tails</simpara></entry>
<entry align="left" valign="top"><simpara>Heads</simpara></entry>
<entry align="left" valign="top"><simpara>Step left.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Yes, this may seem like a particularly unsophisticated algorithm.  Nevertheless, random walks can be used to model phenomena that occur in the real world, from the movements of molecules in a gas to the behavior of a gambler spending a day at the casino.   For us, we begin this book studying a random walk with three goals in mind.</simpara>
</section>
<section id="_the_random_walker_class">
<title>The Random Walker Class</title>
<formalpara><title>Throughout the book, we’ll periodically need a basic understanding of randomness, probability, and Perlin noise.  The random walk will allow us to demonstrate a few key points that will come in handy later.</title><para>Let’s review a bit of object-oriented programming (“OOP”) first by building a “Walker” object.   This will be only a cursory review.  If you have never worked with OOP before, you may want something more comprehensive; I’d suggest stopping here and reviewing the <ulink url="http://processing.org/learning/objects/">basics on the Processing website</ulink> before continuing.</para></formalpara>
<simpara>An <emphasis role="strong"><emphasis>object</emphasis></emphasis> in Processing is an entity that has both data and functionality.  We are looking to design a Walker object that both keeps track of its data (where it exists on the screen) and has the capability to perform certain actions (such as draw itself or take a step).</simpara>
<simpara>A <emphasis role="strong"><emphasis>class</emphasis></emphasis> is the template for building actual instances of objects.  Think of a class as the cookie cutter; the objects are the cookies themselves.    Let’s begin by defining this template—what it means to be a Walker object.</simpara>
<simpara>The Walker only needs two pieces of data—a number for its x-location and one for its y-location.</simpara>
<programlisting language="java" linenumbering="unnumbered">---
class Walker {
  // Objects have data.
  int x;
  int y;
---</programlisting>
<simpara>Every class must have a constructor, a special function that is called when the object is first created.  You can think of it as the object’s <phrase role="function">setup()</phrase>.   There, we’ll initialize the Walker’s starting location (in this case, the center of the window).</simpara>
<programlisting language="java" linenumbering="unnumbered">---
  // Objects have a constructor where they are initialized.
  Walker() {
    x = width/2;
    y = height/2;
  }
---</programlisting>
<simpara>Finally, in addition to data, classes can be defined with functionality.  In this example, a Walker has two functions.   We first write a function to display itself (as a white dot).</simpara>
<programlisting language="java" linenumbering="unnumbered">---
  // Objects have functions.
  void display() {
    stroke(255);
    point(x,y);
  }
---</programlisting>
<simpara>The second function directs the object to take a step.   Now, this is where things get a bit more interesting.   Remember that floor on which we were taking random steps?  Well, now we can use a Processing window in that same capacity.  There are four possible steps—a step to the right can be simulated by incrementing x ( x<literal>); to the left by decrementing x (x--); forward by going down a pixel (y</literal>); and backward by going up a pixel (y--).   How do we pick from these four choices?   Earlier we stated that we could flip two coins.  In Processing, however, when we want to randomly choose from a list of options, we can pick a random number using <phrase role="function">random()</phrase>.</simpara>
<programlisting language="java" linenumbering="unnumbered">---
  void step() {
    // 0, 1, 2, or 3
    int choice = int(random(4));
---</programlisting>
<simpara>The above line of code picks a random floating point number between 0 and 4 and converts it to an integer, resulting in 0, 1, 2, or 3.   Technically speaking, the highest number will never be 4.0, but rather 3.999999999 (with as many 9s as there are decimal places); since the process of converting to an integer lops off the decimal place, the highest int we can get is 3.  Next, we take the appropriate step (left, right, up, or down) depending on which random number was picked.</simpara>
<programlisting language="java" linenumbering="unnumbered">---
    // The random “choice” determines our step.
    if (choice == 0) {
      x++;
    } else if (choice == 1) {
      x--;
    } else if (choice == 2) {
      y++;
    } else {
      y--;
    }
  }
}
---</programlisting>
<simpara>Now that we’ve written the class, it’s time to make an actual Walker object in the main part of our sketch—<phrase role="function">setup()</phrase> and <phrase role="function">draw()</phrase>.   Assuming we are looking to model a single random walk, we declare one global variable of type Walker.</simpara>
<programlisting language="java" linenumbering="unnumbered">---
// A Walker object
Walker w;
---</programlisting>
<simpara>Then we create the object in <phrase role="function">setup()</phrase> by calling the constructor with the <phrase role="function">new</phrase> operator.</simpara>
<simpara>====Example I.1: Traditional Random Walk</simpara>
<programlisting language="java" linenumbering="unnumbered">---
void setup() {
  size(640,360);
  // Create the Walker.
  *w = new Walker();*
  background(0);
}
---</programlisting>
<simpara>Finally, during each cycle through <phrase role="function">draw()</phrase>, we ask the Walker to take a step and draw a dot.</simpara>
<programlisting language="java" linenumbering="unnumbered">---
void draw() {
  // Call functions on the Walker.
  *w.step();
  w.display();*
}
---</programlisting>
<simpara>Since we only draw the background once in <phrase role="function">setup()</phrase> (rather than clearing it continually each time through <phrase role="function">draw()</phrase>), we see the trail of the random walk in our Processing window.</simpara>
<simpara>image:imgs/RandomWalkTraditional1.png [Random Walk Traditional, canvas=processingjs/RandomWalkTraditional1/RandomWalkTraditional1.pde,processingjs/RandomWalkTraditional1/Walker.pde]</simpara>
<simpara>There are a couple improvements we could make to the random walker.  For one, this walker’s step choices are limited to four—up, down, left, and right.  But any given pixel in the window has eight possible neighbors, and a ninth possibility is to stay in the same place.</simpara>
<simpara><inlinemediaobject>
  <imageobject>
  <imagedata fileref="imgs/intro_1-01.png"/>
  </imageobject>
  <textobject><phrase>Figure I.1</phrase></textobject>
</inlinemediaobject></simpara>
<simpara>To implement a walker that can step to any neighboring pixel (or stay put) we could then pick a number between zero and eight (nine possible choices).  However, a more efficient way to write the code would be to simply pick from three possible steps along the x-axis (-1, 0, or 1) and three possible steps along the y-axis.</simpara>
<programlisting language="java" linenumbering="unnumbered">---
  void step() {
    // Yields -1, 0, or 1
    int stepx = int(random(3))-1;
    int stepy = int(random(3))-1;
    x += stepx;
    y += stepy;
  }
---</programlisting>
<simpara>Taking this a step further, we could use floating point numbers (i.e. decimal numbers) for x and y instead and move according to an arbitrary random value between -1 and 1.</simpara>
<programlisting language="java" linenumbering="unnumbered">---
  void step() {
    float stepx = random(-1, 1);
    float stepy = random(-1, 1);
    x += stepx;
    y += stepy;
  }
---</programlisting>
<simpara>All of these variations on the “traditional” random walk have one thing in common: at any moment in time, the probability that the walker will take a step in a given direction is equal to the probability that the walker will take a step in any direction.   In other words, if there are four possible steps, there is a one in four (or 25%) chance the walker will take any given step.  With nine possible steps, it’s a one in nine (or 11.1%) chance.</simpara>
<simpara>Conveniently, this is how the <phrase role="function">random()</phrase> function works.  Processing’s random number generator (which operates behind the scenes) produces what is known as a “uniform” distribution of numbers.   We can test this distribution with a Processing sketch that counts each time a random number is picked and graphs it as the height of a rectangle.</simpara>
<simpara>image:imgs/RandomDistributionSimple.png [Random Distribution, canvas=processingjs/RandomDistributionSimple/RandomDistributionSimple.pde]</simpara>
<simpara>====Example I.2: Random number distribution</simpara>
<programlisting language="java" linenumbering="unnumbered">---
// An array to keep track of how often random numbers are picked
int[] randomCounts;</programlisting>
<simpara>void setup() {
  size(640,240);
  randomCounts = new int[20];
}</simpara>
<simpara>void draw() {
  background(255);</simpara>
<literallayout class="monospaced">// Pick a random number and increase the count.
int index = int(random(randomCounts.length));
randomCounts[index]++;</literallayout>
<literallayout class="monospaced">  // Graphing the results
  stroke(0);
  fill(175);
  int w = width/randomCounts.length;
  for (int x = 0; x &lt; randomCounts.length; x++) {
    rect(x*w,height-randomCounts[x],w-1,randomCounts[x]);
  }
}
---</literallayout>
<simpara>The above screenshot shows the result of the sketch running for a few minutes.   Notice how each bar of the graph differs in height.   Our sample size (i.e. the number of random numbers we’ve picked) is rather small and there are some random discrepancies, where certain numbers are picked more often.  Over time, with a good random number generator, this would even out.</simpara>
<example>
<title>Pseudo-Random Numbers</title>
<simpara>The random numbers we get from the <phrase role="function">random()</phrase> function are not truly random and are therefore known as “pseudo-random.”  They are the result of a mathematical function that simulates randomness.  This function would yield a pattern over time, but that time period is so long that for us, it’s just as good as pure randomness!</simpara>
</example>
<example>
<title>Exercise I.1</title>
<simpara>Create a random walker that has a tendency to move down and to the right.  (We’ll see the solution to this in the next section.)</simpara>
</example>
</section>
<section id="_probability_and_non_uniform_distributions">
<title>Probability and Non-Uniform Distributions</title>
<simpara>Remember when you first started programming in Processing?  Perhaps you wanted to draw a lot of circles on the screen.  So you said to yourself: “Oh, I know.  I’ll draw all these circles at random locations, with random sizes, and random colors.”   In a computer graphics system, it’s often easiest to seed a system with randomness.   In this book, however, we’re looking to build systems modeled on what we see in nature.  Defaulting to randomness is not a particularly thoughtful solution to a design problem—in particular, the kind of problems that involve creating an organic or natural-looking simulation.</simpara>
<simpara>With a few tricks, we can change the way we use <phrase role="function">random()</phrase> to produce “non-uniform” distributions of random numbers.    This will come in handy throughout the book as we look at a number of different scenarios.    When we examine genetic algorithms, for example, we’ll need a methodology for performing “selection”—which members of our population should be selected to pass their DNA down to the next generation.   Remember the concept of survival of the fittest?    Let’s say we have a population of monkeys evolving.  Not every monkey will have a equal chance of reproducing.  To simulate Darwinian evolution, we can’t simply pick two random monkeys to be parents.  We need the more “fit” ones to be more likely to be chosen.  We need to define the “probability of the fittest.”   For example, a particularly fast and strong monkey might have a 90% chance of procreating, while a weaker one has only a 10% chance.</simpara>
<simpara>Let’s review the basic principles of probability, first looking at “Single Event Probability,” i.e. the likelihood of something to occur.</simpara>
<simpara>Given a system with a certain number of possible outcomes, the probability of any given event occurring is the number of outcomes that qualify as that event divided by the total number of possible outcomes. The simplest example is a coin toss. There are a total of two possible outcomes (heads or tails). There is only one way to flip heads. Therefore, the probability of heads is one divided by two, i.e. 1/2 or 50%.</simpara>
<simpara>Consider a deck of fifty-two cards. The probability of drawing an ace from that deck is:</simpara>
<simpara><emphasis>*number of aces / number of cards = 4 / 52 = 0.077 = ~ 8%*</emphasis></simpara>
<simpara>The probability of drawing a diamond is:</simpara>
<simpara><emphasis>*number of diamonds / number of cards = 13 / 52 = 0.25 = 25%*</emphasis></simpara>
<simpara>We can also calculate the probability of multiple events occurring in sequence as the product of the individual probabilities of each event.</simpara>
<simpara>The probability of a coin coming up heads three times in a row is:</simpara>
<simpara><emphasis>*(1 / 2) * (1 / 2) * (1 / 2) =  1 / 8 (or 0.125).*</emphasis></simpara>
<simpara>In other words, a coin will land heads three times in a row one out of eight times (with each “time” being three tosses).</simpara>
<example>
<title>Exercise I.2</title>
<simpara>What is the probability of drawing two aces in a row from the deck of cards?</simpara>
</example>
<simpara>There are a few different techniques for using the <phrase role="function">random()</phrase> function with probability in code. For example, if we fill an array with a selection of numbers (some repeated), we can randomly pick from that array and generate events based on what we select.</simpara>
<programlisting language="java" linenumbering="unnumbered">---
int[] stuff = new int[5]
// 1 is stored in the array twice to increase its likelihood of being picked.
stuff[0] = 1;
stuff[1] = 1;
stuff[2] = 2;
stuff[3] = 3;
stuff[4] = 3;
// Picking a random element from an array
int index = int(random(stuff.length));
---</programlisting>
<simpara>If you run this code, there will be a 40% chance of printing the value 1, a 20% chance of printing 2, and a 40% chance of printing 3.</simpara>
<simpara>Another strategy is to ask for a random number (for simplicity, we’ll consider random floating point values between 0 and 1) and allow an event to occur only if the random number we pick is within a certain range.  For example:</simpara>
<programlisting language="java" linenumbering="unnumbered">---
// A probability of 10%
float prob = 0.10;
// A random floating point value between 0 and 1
float r = random(1);
// If our random number is less than 0.1
if (r &lt; prob) {
   // DO SOMETHING!
}
---</programlisting>
<simpara>This same technique can also be applied to multiple outcomes.</simpara>
<simpara><emphasis>*Outcome A — 60% | Outcome B — 10% | Outcome C — 30%*</emphasis></simpara>
<simpara>To implement this in code, we pick one random float and check where it falls.</simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis>between 0.00 and 0.60 (60%) –&gt; outcome A</emphasis>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>between 0.60 and 0.70 (10%) –&gt; outcome B</emphasis>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>between 0.70 and 1.00 (30%) –&gt; outcome C</emphasis>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="java" linenumbering="unnumbered">---
float num = random(1);</programlisting>
<simpara>if (num &lt; 0.6) {
  // Outcome A

} else if (num &lt; 0.7) {
  // Outcome B

} else {
  // Outcome C
}
---</simpara>
<simpara>We could use the above methodology to create a random walker that tends to move to the right.  Here is an example of a Walker with the following probabilities:</simpara>
<itemizedlist>
<listitem>
<simpara>
chance of moving up:          20%
</simpara>
</listitem>
<listitem>
<simpara>
chance of moving down:        20%
</simpara>
</listitem>
<listitem>
<simpara>
chance of moving left:        20%
</simpara>
</listitem>
<listitem>
<simpara>
chance of moving right:       40%
</simpara>
</listitem>
</itemizedlist>
<simpara>image:imgs/RandomWalkTendsToRight.png [Random Walk Tends to Right, canvas=processingjs/RandomWalkTendsToRight/RandomWalkTendsToRight.pde,processingjs/RandomWalkTendsToRight/Walker.pde]</simpara>
<simpara>====Example I.3: Walker that tends to move to the right</simpara>
<programlisting language="java" linenumbering="unnumbered">---
  void step() {</programlisting>
<literallayout class="monospaced">    float r = random(1);
    // A 40% of moving to the right!
    if (r &lt; 0.4) {
      x++;
    } else if (r &lt; 0.6) {
      x--;
    } else if (r &lt; 0.8) {
      y++;
    } else {
      y--;
    }
  }
---</literallayout>
<example>
<title>Exercise I.3</title>
<simpara>Create a random walker with dynamic probabilities.  For example, can you give it a 50% chance of moving in the direction of the mouse?</simpara>
</example>
</section>
<section id="_a_normal_distribution_of_random_numbers">
<title>A Normal Distribution of Random Numbers</title>
<simpara>Let’s go back to that population of simulated Processing monkeys.  Your program generates a thousand “Monkey” objects, each with a “height” value between 200 and 300 (as his is a world of monkeys that have heights between 200 and 300 pixels).</simpara>
<programlisting language="java" linenumbering="unnumbered">---
float h = random(200,300);
---</programlisting>
<simpara>Does this accurately depict the heights of real-world beings?   Think of a crowded sidewalk in New York City.   Pick any person off the street and it may appear that their height is random.  Nevertheless, it’s not the kind of random that the <phrase role="function">random()</phrase> produces.   People’s heights are not uniformly distributed; there are a great deal more people of average height than there are very tall or very short ones.   To simulate nature, we may want it to be more likely that our monkeys are of average height (250 pixels), yet allow them to still on occasion be very short or very tall.</simpara>
<simpara>A distribution of values that cluster around an average (referred to as the “mean”) is known as a “normal” distribution.   It is also called the Gaussian distribution (named for mathematician Carl Friedrich Gauss) or, if you are French, the Laplacian distribution (named for Pierre-Simon Laplace).  Both mathematicians were working concurrently in the early nineteenth century on defining such a distribution.</simpara>
<simpara>When you graph the distribution, you get something that looks like the following, informally known as the bell curve.</simpara>
<simpara>image:imgs/BellCurve.png</simpara>
<simpara>The curve is generated by a mathematical function that defines the probability of any given value occurring as a function of the mean (often written as μ, the Greek letter <emphasis>mu</emphasis>) and standard deviation (σ, the Greek letter <emphasis>sigma</emphasis>).</simpara>
<simpara>The mean is pretty easy to understand.  In the case of our height values between 200 and 300, you probably have an intuitive sense of the mean (i.e. average) as 250.    However, what if I were to say that the standard deviation is 3 or 15?   What does this mean for the numbers?  The graphs above should give us a hint. The graph on the left shows us the distribution with a very low standard deviation, where the majority of the values cluster closely around the mean.  The graph on the right shows us a higher standard deviation, where the values are more evenly spread out from the average.
 The numbers work out as follows.  Given a population, 68% of the members of that population will have values in the range of one standard deviation from the mean, 98% within two standard deviations, and 99.7% within three standard deviations.   Given a standard deviation of five pixels, only 0.3% of the monkey heights will be less than 235 pixels (three standard deviations below the mean of 250) or greater than 265 pixels (three standard deviations above the mean of 250).</simpara>
<example>
<title>Calculating Mean and Standard Deviation</title>
<simpara>Consider a class of ten students who receive the following scores (out of 100) on a test:</simpara>
<simpara><emphasis>85, 82, 88, 86, 85, 93, 98, 40, 73, 83</emphasis></simpara>
<simpara><emphasis role="strong"><emphasis>The mean is the average:  81.3</emphasis></emphasis></simpara>
<simpara>The standard deviation is calculated as the square root of the average of the squares of deviations around the mean. In other words, take the difference from the mean for each person and square it (variance). Calculate the average of all these values and take the square root as our standard deviation.</simpara>
<informaltable
frame="all"
rowsep="1" colsep="1"
>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top">Score  </entry>
<entry align="left" valign="top">Difference from Mean </entry>
<entry align="left" valign="top">Variance</entry>
</row>
</thead>
<tfoot>
<row>
<entry align="left" valign="top"><simpara></simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong">Average Variance:</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>254.23</simpara></entry>
</row>
</tfoot>
<tbody>
<row>
<entry align="left" valign="top"><simpara>85</simpara></entry>
<entry align="left" valign="top"><simpara>85-81.3 = 3.7</simpara></entry>
<entry align="left" valign="top"><simpara>(3.7)<superscript>2</superscript> = 13.69</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>40</simpara></entry>
<entry align="left" valign="top"><simpara>40-81.3 = -41.3</simpara></entry>
<entry align="left" valign="top"><simpara>(-41.3)<superscript>2</superscript> = 1705.69</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>etc.</simpara></entry>
<entry align="left" valign="top"><simpara></simpara></entry>
<entry align="left" valign="top"><simpara></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong"><emphasis>The standard deviation is the square root of the average variance = 15.13</emphasis></emphasis></simpara>
</example>
<simpara>Luckily for us, to use a normal distribution of random numbers in a Processing sketch, we don’t have to do any of these calculations ourselves.   Instead, we can make use of a class known as Random, which we get for free as part of the default Java libraries imported into Processing (see <ulink url="http://docs.oracle.com/javase/6/docs/api/java/util/Random.html">http://docs.oracle.com/javase/6/docs/api/java/util/Random.html</ulink> for more information).</simpara>
<simpara>To use the Random class, we must first declare a variable of type Random and create the Random object in <phrase role="function">setup()</phrase>.</simpara>
<programlisting language="java" linenumbering="unnumbered">---
// We use the variable name “generator” as what we
// have here can be thought of as a random number generator.
Random generator;</programlisting>
<simpara>void setup() {
  size(640,360);
  generator = new Random();
}
---</simpara>
<simpara>If we want to produce a random number with a normal (or Gaussian) distribution each time we run through <phrase role="function">draw()</phrase>, it’s as easy as calling the function <phrase role="function">nextGaussian()</phrase>.</simpara>
<programlisting language="java" linenumbering="unnumbered">---
void draw() {
  // Asking for a Gaussian random number
  float num = generator.nextGaussian();
}
---</programlisting>
<simpara>Here’s the thing.  What are we supposed to do with this value?  What if we wanted to use it, for example, to assign the x-position of a shape we draw on screen?</simpara>
<simpara>The <phrase role="function">nextGaussian()</phrase> function returns a normal distribution of random numbers with the following parameters: <emphasis role="strong"><emphasis>a mean of zero</emphasis></emphasis> and <emphasis role="strong"><emphasis>a standard deviation of one</emphasis></emphasis>.    Let’s say we want a mean of 360 (the center horizontal pixel in a window of width 640) and a standard deviation of 60 pixels.   We can adjust the value to our parameters by multiplying it by the standard deviation and adding the mean.</simpara>
<simpara>====Example I.3: Gaussian distribution</simpara>
<programlisting language="java" linenumbering="unnumbered">---
void draw() {
  // Note nextGaussian() returns a double.
  float num = (float) generator.nextGaussian();
  float sd = 60;
  float mean = 360;</programlisting>
<literallayout class="monospaced">// Multiply by standard deviation and add the mean.
float x = sd*num + mean;</literallayout>
<literallayout class="monospaced">  noStroke();
  fill(255,10);
  ellipse(x,180,16,16);
}
---</literallayout>
<simpara>image:imgs/Gaussian1.png [Gaussian Distribution, canvas=processingjs/Gaussian1/Gaussian1.pde]</simpara>
<simpara>distribution.  The brightest spot is near the center, where most of the values cluster, but every so often circles are drawn farther to the right or left of the center.</simpara>
<example>
<title>Exercise I.4</title>
<simpara>Consider a simulation of paint splatter drawn as a collection of colored dots. Most of the paint clusters around a central location, but some dots do splatter out towards the edges.  Can you use a normal distribution of random numbers to generate the locations of the dots?  Can you also use a normal distribution of random numbers to generate a palette of color?</simpara>
</example>
<example>
<title>Exercise I.5</title>
<simpara>A Gaussian random walk is defined as one in which the step size (how far you move in a given direction) is generated with a normal distribution.  Implement this variation of our random walk.</simpara>
</example>
</section>
<section id="_a_custom_distribution_of_random_numbers">
<title>A Custom Distribution of Random Numbers</title>
<simpara>There will come a time in your life when you do not want a uniform distribution of random values, or a Gaussian one.   Let’s imagine for a moment that you are a random walker in search of food.   Moving randomly around a space seems like a reasonable strategy for finding something to eat.   After all, you don’t know where the food is, so you might as well search randomly until you find it.  The problem, as you may have noticed, is that random walkers return to previously visited locations many times (this is known as “oversampling.”)   One strategy to avoid such a problem is to, every so often, take a very large step.   This allows the walker to forage randomly around a specific location while periodically jumping very far away to reduce the amount of oversampling.   This variation on the random walk (known as a Lévy flight) requires a custom set of probabilities.   Though not an exact implementation of a Lévy flight, we could state the probability distribution as follows: the longer the step, the less likely it is to be picked; the shorter the step, the more likely.</simpara>
<simpara>Earlier in this prologue, we saw that we could generate custom probability distributions by filling an array with values (some duplicated so that they would be picked more frequently) or by testing the result of <phrase role="function">random()</phrase>.  Certainly, we could implement a Levy flight by saying there is a 1% chance of the walker taking a large step.</simpara>
<programlisting language="java" linenumbering="unnumbered">---
float r = random(1);
// A 1% chance of taking a large step
if (r &lt; 0.01) {
  xstep = random(-100,100);
  ystep - random(-100,100);
} else {
  xstep = random(-1,1);
  ystep - random(-1,1);
}
---</programlisting>
<simpara>However, this reduces the probabilities to a fixed number of options.  What if we wanted to make a more general rule—the higher a number, the more likely it is to be picked?  3.145 would be more likely to be picked than 3.144, even if that likelihood is just a tiny bit greater.  In other words, if x is the random number, we could map the likelihood on the y-axis with y = x.</simpara>
<simpara>image:imgs/intro_2-01.png
￼
If we can figure out how to generate a distribution of random numbers according to the above graph, then we will be able to apply the same methodology to any curve for which we have a formula.</simpara>
<simpara>One solution is to pick two random numbers instead of one.  The first random number is just that, a random number.  The second one, however, is what we’ll call a “qualifying random value.”  It will tell us whether to use the first one or throw it away and pick another one.  Numbers that have an easier time “qualifying” will be picked more often, and numbers that rarely qualify will be picked infrequently.   Here are the steps (for now, let’s consider only random values between 0 and 1.)</simpara>
<formalpara><title>If R2 is not less than P, go back to step 1 and start over.</title><para>Here we are saying that the likelihood that a random value will qualify is equal to the random number itself.  Let’s say we pick 0.1 for R1.  This means that R1 will have a 10% chance of qualifying.  If we pick 0.83 for R1 then it will have a 83% chance of qualifying.  The higher the number, the greater the likelihood that we will actually use it.
 Here is a function (named for the Monte Carlo method, which was named for the Monte Carlo casino) that implements the above algorithm, returning a random value between zero and one.</para></formalpara>
<programlisting language="java" linenumbering="unnumbered">---
float montecarlo() {
  // We do this “forever” until we find a qualifying random value.
  while (true) {
    // Pick a random value.
    float r1 = random(1);
    // Assign a probability.
    float probability = r1;
    // Pick a second random value.
    float r2 = random(1);
    // Does it qualify?  If so, we’re done!
    if (r2 &lt; probability) {
      return r1;
    }
  }
}
---</programlisting>
<example>
<title>Exercise I.6</title>
<simpara>Use a custom probability distribution to vary the size of a step taken by the random walker.   The step size can be achieved by affecting the range of values picked.  Can you map the probability exponentially—i.e. making the likelihood a value is picked equal to the value squared?</simpara>
<programlisting language="java" linenumbering="unnumbered">---
  // A uniform distribution of step sizes. Change this!
  float stepsize = random(-10,10);</programlisting>
<literallayout class="monospaced">float stepx = random(-stepsize,stepsize);
float stepy = random(-stepsize,stepsize);</literallayout>
<literallayout class="monospaced">  x += stepx;
  y += stepy;
---</literallayout>
<simpara>(Later we’ll see how to do this more efficiently using vectors.)</simpara>
</example>
</section>
<section id="_perlin_noise_a_smoother_approach">
<title>Perlin Noise (A Smoother Approach)</title>
<simpara>One of the qualities of a good random number generator is that the numbers produced have no relationship.   If they exhibit no discernible pattern, they are considered <emphasis>random</emphasis>.</simpara>
<simpara>As we are beginning to see, a little bit of randomness can be a good thing when programming organic, lifelike behaviors.  However, randomness as the single guiding principle is not necessarily natural.   An algorithm known as “Perlin noise,” named for its inventor Ken Perlin, takes this concept into account.   Perlin developed the noise function while working on the original <emphasis>Tron</emphasis> movie in the early 1980s.  It was designed to create procedural textures for computer-generated effects; in 1997 Perlin won an Academy Award in Technical Achievement for this work. Perlin noise can be used to generate a variety of interesting effects such as clouds, landscapes, and patterned textures like marble.</simpara>
<simpara>“Perlin noise” has a more organic quality because it produces a naturally ordered (i.e. “smooth”) sequence of pseudo-random numbers.    The graph on the left below shows Perlin noise over time (the x-axis represents time; note how the curve is smooth) while the graph on the right shows pure random numbers over time.  (The code for generating these graphs is available with the accompanying book downloads.)</simpara>
<simpara>image:imgs/noise_random_graphs.png</simpara>
<example>
<title>Noise Detail</title>
<simpara>If you visit the Processing.org noise reference, you’ll find that noise is calculated over several “octaves.” You can change the number of octaves and their relative importance by calling the <ulink url="http://processing.org/reference/noiseDetail_.html">noiseDetail()</ulink> function.  This in turn changes how the noise function behaves.</simpara>
<simpara>You can learn more about how noise works from <ulink url="http://www.noisemachine.com/talk1/">Ken Perlin</ulink> himself.</simpara>
</example>
<simpara>Processing has a built-in implementation of the Perlin noise algorithm with the function <phrase role="function">noise()</phrase>.  The <phrase role="function">noise()</phrase> function takes one, two, or three arguments (referring to the “space” in which noise is computed: one, two, or three dimensions).  Let’s start by looking at one-dimensional noise.</simpara>
<simpara>Consider for a moment drawing a circle in our Processing window at a random x-location.</simpara>
<programlisting language="java" linenumbering="unnumbered">---
// A random x-location
float x = random(0,width);
ellipse(x,180,16,16);
---</programlisting>
<simpara>Now, instead of a random x-location, we want a Perlin noise x-location that is “smoother.”  You might think that all you need to do is replace random() with noise(), i.e.</simpara>
<simpara><phrase role="strike">float x = noise(0,width);</phrase></simpara>
<simpara>While conceptually this is exactly what we want to do—calculate an x-value that ranges between zero and the width according to Perlin noise—this is not the correct implementation.    While the arguments to the <phrase role="function">random()</phrase> function specify a range of values between a minimum and a maximum, <phrase role="function">noise()</phrase> does not work this way.  Instead, the output range is fixed—it always returns a value between zero and one.  We’ll see in a moment that we can get around this easily with Processing’s <phrase role="function">map()</phrase> function, but first we must examine what exactly <phrase role="function">noise()</phrase> expects us to pass in as an argument.</simpara>
<simpara>We can think of one-dimensional Perlin noise as a linear sequence of values over time.   For example:</simpara>
<informaltable
frame="all"
rowsep="1" colsep="1"
>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Time   </entry>
<entry align="left" valign="top">Noise Value</entry>
</row>
</thead>
<tfoot>
<row>
<entry align="left" valign="top"><simpara>4</simpara></entry>
<entry align="left" valign="top"><simpara>0.366</simpara></entry>
</row>
</tfoot>
<tbody>
<row>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>0.365</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>0.363</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>2</simpara></entry>
<entry align="left" valign="top"><simpara>0.363</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>3</simpara></entry>
<entry align="left" valign="top"><simpara>0.364</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Now, in order to access a particular noise value in Processing, we have to pass a specific moment in time to the <phrase role="function">noise()</phrase> function.  For example:</simpara>
<programlisting language="java" linenumbering="unnumbered">---
float n = noise(3);
---</programlisting>
<simpara>According to the above table, <phrase role="function">noise(3)</phrase> will return 0.364 at time equals three. We could improve this by using a variable for “time” and asking for a noise value continuously in <phrase role="function">draw()</phrase>.</simpara>
<programlisting language="java" linenumbering="unnumbered">---
float t = 3;</programlisting>
<simpara>void draw() {
  // We need the noise value for a specific “moment in time.”
  float n = noise(t);
  println(n);
}
---</simpara>
<simpara>The above code results in the same value printed over and over.   This is because we are asking for the result of the <phrase role="function">noise()</phrase> function at the same point in “time”—3—over and over.  If we increment the “time” variable <phrase role="var">t</phrase>, however, we’ll get a different result.</simpara>
<programlisting language="java" linenumbering="unnumbered">---
// Typically we would start at time = 0, though this is arbitrary.
float t = 0;</programlisting>
<simpara>void draw() {
  float n = noise(t);
  println(n);
  // Now, we move forward in time!
  t += 0.01;
}
---</simpara>
<simpara>How quickly we increment “t” also affects the smoothness of the noise.   If we make large jumps in time, then we are skipping ahead and the values will be more random.</simpara>
<simpara>image:imgs/intro_3-01.png</simpara>
<simpara>Try running the code several times, incrementing t by 0.01, 0.02, 0.05, 0.1, 0.0001, and you will see different results.</simpara>
<simpara>===Mapping Noise</simpara>
<simpara>Now we’re ready to answer the question of what to do with the noise value.   Once we have the value with a range between zero and one, it’s up to us to map that range to what we want.   The easiest way to do this is with Processing’s <phrase role="function">map()</phrase> function.   The <phrase role="function">map()</phrase> function takes five arguments.  First up is the value we want to map, in this case <phrase role="var">n</phrase>.  Then we have to give it the value’s current range (minimum and maximum) followed by our desired range.</simpara>
<simpara>image:imgs/intro_4-01.png</simpara>
<simpara>In this case, we know that noise has a range between zero and one, but we’d like to draw our circle with a range between zero and the window’s width.</simpara>
<programlisting language="java" linenumbering="unnumbered">---
float t = 0;</programlisting>
<simpara>void draw() {
  float n = noise(t);
  // Using map() to customize the range of Perlin noise
  float x = map(n,0,1,0,width);
  ellipse(x,180,16,16);</simpara>
<literallayout class="monospaced">  t += 0.01;
}
---</literallayout>
<simpara>We can apply the exact same logic to our random walker, and assign both its x- and y-values according to Perlin noise.</simpara>
<simpara>image:imgs/NoiseWalk.png [Perlin Noise Walker, canvas=processingjs/NoiseWalk/NoiseWalk.pde,processingjs/NoiseWalk/Walker.pde]</simpara>
<simpara>====Example I.3: Perlin Noise Walker</simpara>
<programlisting language="java" linenumbering="unnumbered">---
class Walker {
  float x,y;</programlisting>
<literallayout class="monospaced">float tx,ty;</literallayout>
<literallayout class="monospaced">Walker() {
  tx = 0;
  ty = 10000;
}</literallayout>
<literallayout class="monospaced">void step() {
  // x- and y-location mapped from noise
  x = map(noise(tx), 0, 1, 0, width);
  y = map(noise(ty), 0, 1, 0, height);</literallayout>
<literallayout class="monospaced">    // Move forward through “time.”
    tx += 0.01;
    ty += 0.01;
  }
}
---</literallayout>
<simpara>Notice how the above example requires an additional pair of variables: <phrase role="var">tx</phrase> and  <phrase role="var">ty</phrase>.  This is because we need to keep track of two “time” variables, one for the x-location of the walker and one for the y-location.   But there is something a bit odd about these variables. Why does <phrase role="var">tx</phrase> start at zero and  <phrase role="var">ty</phrase> at 10,000?  While these numbers are arbitrary choices, we have very specifically initialized our two time variables with different values.  This is because the noise function is deterministic; it gives you the same result for a specific time <phrase role="var">t</phrase> each and every time.  If we asked for the the noise value at the same time <phrase role="var">t</phrase> for both <phrase role="var">x</phrase> and <phrase role="var">y</phrase>, then <phrase role="var">x</phrase> and <phrase role="var">y</phrase> would always be equal, meaning that the walker would only move along a diagonal.   Instead, we simply use two different parts of the noise space, starting at 0 for <phrase role="var">x</phrase> and 10,000 for <phrase role="var">y</phrase> so that <phrase role="var">x</phrase> and <phrase role="var">y</phrase> can appear to act independently of each other.</simpara>
<simpara>image:imgs/intro_5-01.png</simpara>
<simpara>In truth, there is no true concept of “time” at play here.  It’s a useful metaphor to help us understand how the noise function works, but really what we have is space, rather than time.  The graph above depicts a linear sequence of noise values in a one-dimensional space, and we can ask for a value at a specific x-location whenever we want.   In examples, you will often see a variable named <phrase role="var">xoff</phrase> to indicate the “x offset” along the noise graph rather than t for time (as noted in the diagram).</simpara>
<example>
<title>Exercise I.7</title>
<simpara>In the above random walker, the result of the noise function is mapped directly to the walker’s location.  Create a random walker where you instead map the result of the <phrase role="function">noise()</phrase> function to a walker’s step size.</simpara>
</example>
<simpara>===Two-Dimensional Noise</simpara>
<simpara>This idea of noise values living in a one-dimensional space is important because it leads us right into a discussion of two-dimensional space.  Let’s think about this for a moment.  With one-dimensional noise, we have a sequence of values in which any given value is similar to its neighbor.  Because the value is in one dimension, it only has two neighbors: a value that comes before it (to the left on the graph) and one that comes after it (to the right).</simpara>
<simpara>image:imgs/intro_6-01.png</simpara>
<simpara>Two-dimensional noise works exactly the same way conceptually.  The difference of course is that we aren’t looking at values along a linear path, but values that are sitting on a grid.  Think of a piece of graph paper with numbers written into each cell.  A given value will be similar to all of its neighbors: above, below, to the right, to the left, and along any diagonal.</simpara>
<simpara>image:imgs/intro_8-01.png</simpara>
<simpara>If you were to visualize this graph paper with each value mapped to the brightness of a color, we would get something that looks like clouds.  White sits next to light gray, which sits next to gray, which sits next to dark grey, which sits next to black, which sits next to dark gray, etc.</simpara>
<simpara>image:imgs/noisecloud.png</simpara>
<simpara>This is what noise was originally invented for.  Tweak the parameters a bit, play with color, and the resulting image might look more like marble or wood or any other organic texture.</simpara>
<simpara>Let’s take a quick look at how you implement two-dimensional noise in Processing.  If you wanted to color every pixel of a window randomly, you would need a nested loop, one that accessed each pixel and picked a random brightness.</simpara>
<programlisting language="java" linenumbering="unnumbered">---
loadPixels();
for (int x = 0; x &lt; width; x++) {
  for (int y = 0; y &lt; height; y++) {
    // A random brightness!
    float bright = random(255);
    pixels[x+y*width] = color(bright);
  }
}
updatePixels();
---</programlisting>
<simpara>To color each pixel according to the <phrase role="function">noise()</phrase> function, we’ll do exactly the same thing, only instead of calling <phrase role="function">random()</phrase> we’ll call <phrase role="function">noise()</phrase>.</simpara>
<programlisting language="java" linenumbering="unnumbered">---
   _float bright = map(noise(x,y),0,1,0,255);_
---</programlisting>
<simpara>This is a nice start conceptually—it gives you a noise value for every (x,y) location in our two-dimensional space.  The problem is that this won’t have the cloudy quality we want.  Jumping from pixel 200 to pixel 201 is too large of a jump through noise.  Remember, when we worked with one-dimensional noise, we incremented our “time” variable by 0.01 each frame, not by 1!    A pretty good solution to this problem is to just use different variables for the noise arguments.  For example, we could increment a variable called <phrase role="var">xoff</phrase> each time we move horizontally, and a yoff variable each time we move vertically through the nested loops.</simpara>
<programlisting language="java" linenumbering="unnumbered">---
// Start xoff at 0.
_float xoff = 0.0;_</programlisting>
<simpara>for (int x = 0; x &lt; width; x++) {
  // For every xoff, start yoff at 0.
  <emphasis>float yoff = 0.0;</emphasis></simpara>
<literallayout class="monospaced">  for (int y = 0; y &lt; height; y++) {
    // Use xoff and yoff for noise().
    float bright = map(_noise(xoff,yoff)_,0,1,0,255);
    // Use x and y for pixel location.
    pixels[x+y*width] = color(bright);
    // Increment xoff
    _yoff += 0.01;_
  }
  // Increment xoff
  _xoff += 0.01;_
}
---
.Exercise I.8</literallayout>
<informalexample>
<simpara>Play with color, <phrase role="function">noiseDetail()</phrase>, and the rate at which <phrase role="var">xoff</phrase> and <phrase role="var">yoff</phrase> are incremented to achieve different visual effects.</simpara>
</informalexample>
<example>
<title>Exercise I.9</title>
<simpara>Add a third argument to noise that increments once per cycle through <phrase role="function">draw()</phrase> to animate the two-dimensional noise.</simpara>
</example>
<example>
<title>Exercise I.10</title>
<simpara>Use the noise values as the heights of a landscape.  See the screenshot below as a reference.</simpara>
<simpara>image:imgs/NoiseLandscape.png [Tree Perlin Noise, canvas=processingjs/NoiseLandscape/NoiseLandscape.pde,processingjs/NoiseLandscape/Landscape.pde]</simpara>
</example>
<simpara>We’ve examined several traditional uses of Perlin noise in this section.  With one-dimensional noise, we used smooth values to assign the location of an object to give the appearance of wandering.  With two-dimensional noise, we created a cloudy pattern with smoothed values on a plane of pixels.  It’s important to remember, however, that Perlin noise values are just that—values.  They aren’t inherently tied to pixel locations or color.  Any example in this book that has a variable could be controlled via Perlin noise.  When we model a wind force, its strength could be controlled by Perlin noise.  Same goes for the angles between the branches in a fractal tree pattern, or the the speed and direction of objects moving along a grid in a flow field simulation.</simpara>
<simpara>image:imgs/TreeStochasticNoise.png [Tree Perlin Noise, canvas=processingjs/TreeStochasticNoise/TreeStochasticNoise.pde] CAPTION: Tree with Perlin noise  image:imgs/Flow.png [Perlin noise flow field, canvas=processingjs/Flow/Flow.pde,processingjs/Flow/FlowField.pde,processingjs/Flow/Vehicle.pde] CAPTION: Perlin noise flow field</simpara>
</section>
<section id="_onward">
<title>Onward</title>
<simpara>We began this chapter by talking about how randomness can be a crutch.  In many ways, it’s the most obvious answer to the kinds of questions we ask continuously—how should this object move? What color should it be?  This obvious answer, however, can also be a lazy one.</simpara>
<simpara>As we finish off the introduction, it’s also worth noting that we could just as easily fall into the trap of using Perlin noise as a crutch.   How should this object move? Perlin noise!  What color should it be?  Perlin noise!  How fast should it grow?  Perlin noise!</simpara>
<simpara>The point of all of this is not to say that you should or should not use randomness.  Or that you should or should not use Perlin noise.   The point is that the rules of your system are defined by you and the larger your toolbox, the more choices you’ll have as you implement those rules.   The goal of this book is to fill your toolbox.  If all you know is random, then your design thinking is limited.  Sure, Perlin noise helps, but you’ll need more.  A lot more.</simpara>
<simpara>I think we’re ready to begin.</simpara>
</section>
<blockquote>
<simpara>“Roger, Roger. What&#8217;s our vector, Victor?”
        —Captain Oveur, Airplane</simpara>
</blockquote>
<simpara>This book is all about looking at the world around us and coming up with clever ways to simulate that world with code.  Divided into three parts, the book will start by looking at basic physics—how an apple falls from a tree, a pendulum swings in the air, the earth revolves around the sun, etc.  Absolutely everything contained within the first five chapters of this book requires the use of the most basic building block for programming motion—the <emphasis role="strong"><emphasis>vector</emphasis></emphasis>.   And so this is where we begin our story.</simpara>
<simpara>Now, the word <emphasis role="strong"><emphasis>vector</emphasis></emphasis> can mean a lot of different things. Vector is the name of a new wave rock band formed in Sacramento, CA in the early 1980s.  It’s the name of a breakfast cereal manufactured by Kellogg’s Canada.   In the field of epidemiology, a vector is used to describe an organism that transmits infection from one host to another.  In the C++ programming language, a Vector (std::vector) is an implementation of a dynamically resizable array data structure.  While all these definitions are interesting, they’re not what we are looking for.   What we want is called a <emphasis role="strong">Euclidean vector</emphasis> (named for the Greek mathematician Euclid and also known as a geometric vector).  When you see the term “vector” in this book, you can assume it refers to a Euclidean vector defined as:</simpara>
<simpara><emphasis role="strong"><emphasis>A vector is an entity that has both magnitude and direction.</emphasis></emphasis></simpara>
<simpara>A vector is typically drawn as a arrow; the direction is indicated by where the arrow is pointing, and the magnitude by the length of the arrow itself.</simpara>
<simpara>image:imgs/chapter01_1-01.png</simpara>
<simpara><emphasis role="strong"><phrase role="note to self">REDO THIS DIAGRAM NOW TO FIT NEW DEFINITION</phrase></emphasis></simpara>
<simpara>In the diagram above, the vector is drawn as an arrow from point A to point B and serves as an instruction for how to travel from A to B.</simpara>
<section id="_1_1_vectors_you_complete_me">
<title>1.1 Vectors, You Complete Me</title>
<simpara>Before we dive into more of the details about vectors, let’s look at a basic Processing example that demonstrates why we should care about vectors in the first place.  If you’ve read any of the introductory Processing textbooks or taken a class on programming with Processing (and hopefully you’ve done one of these things to help prepare you for this book), you probably, at one point or another, learned to how to write a simple bouncing ball sketch.</simpara>
<simpara>image:imgs/chapter01_2-01.png</simpara>
<simpara>====Example 1.1: Bouncing ball with no vectors</simpara>
<programlisting language="java" linenumbering="unnumbered">---
// Variables for location and speed of ball.
float x = 100;
float y = 100;
float xspeed = 1;
float yspeed = 3.3;</programlisting>
<simpara>void setup() {
  size(200,200);
  smooth();
  background(255);
}</simpara>
<simpara>void draw() {
  background(255);</simpara>
<literallayout class="monospaced">// Move the ball according to its speed.
x = x + xspeed;
y = y + yspeed;</literallayout>
<literallayout class="monospaced">// Check for bouncing
if ((x &gt; width) || (x &lt; 0)) {
  xspeed = xspeed * -1;
}
if ((y &gt; height) || (y &lt; 0)) {
  yspeed = yspeed * -1;
}</literallayout>
<literallayout class="monospaced">  stroke(0);
  fill(175);
  // Display the ball at the location x,y.
  ellipse(x,y,16,16);
}
---</literallayout>
<simpara>In the above example, we have a very simple world—a blank canvas with a circular shape (a “ball”) traveling around.  This ball has some properties, which are represented in the code as variables.</simpara>
<literallayout class="monospaced">*_LOCATION:_* *_x and y_*
*_SPEED:_*    *_xspeed and yspeed_*</literallayout>
<simpara>In a more advanced sketch, we could imagine having many more variables:</simpara>
<literallayout class="monospaced">*_ACCELERATION:_*     *_xacceleration and yacceleration_*
*_TARGET LOCATION:_*  *_xtarget and ytarget_*
*_WIND:_*             *_xwind and ywind_*
*_FRICTION:_*         *_xfriction and yfriction_*</literallayout>
<simpara>It’s becoming more and more clear that for every concept in this world (wind, location, acceleration, etc.), we need two variables.  And this is only a two-dimensional world. In a 3D world, we’ll need <emphasis role="strong"><phrase role="var">x</phrase></emphasis>, <emphasis role="strong"><phrase role="var">y</phrase></emphasis>, <emphasis role="strong"><phrase role="var">z</phrase></emphasis>, <emphasis role="strong"><phrase role="var">xspeed</phrase></emphasis>, <emphasis role="strong"><phrase role="var">yspeed</phrase></emphasis>, <emphasis role="strong"><phrase role="var">zspeed</phrase></emphasis>, and so on.</simpara>
<simpara>Wouldn’t it be nice if we could simplify our code and use fewer variables?</simpara>
<simpara>Instead of:</simpara>
<programlisting language="java" linenumbering="unnumbered">---
float x;
float y;
float xspeed;
float yspeed;
---</programlisting>
<simpara>Wouldn’t it be nice to have. . .</simpara>
<programlisting language="java" linenumbering="unnumbered">---
Vector location;
Vector speed;
---</programlisting>
<simpara>Taking this first step in using vectors won’t allow us to do anything new.  Just adding vectors won’t magically make your Processing sketches simulate physics; however, they will simplify your code and provide a set of functions for common mathematical operations that happen over and over and over again while programming motion.</simpara>
<simpara>As an introduction to vectors, we’re going to live in two dimensions for quite some time (at least until we get through the first several chapters.)  All of these examples can be fairly easily extended to three dimensions (and the class we will use—[class]*PVector*—allows for three dimensions.)  However, for the time being, it’s easier to start with just two.</simpara>
</section>
<section id="_1_2_vectors_what_are_they_to_us_processing_programmers">
<title>1.2 Vectors: What are they to us Processing programmers?</title>
<simpara>One way to think of a vector is the difference between two points.   Consider how you might go about providing instructions to walk from one point to another.</simpara>
<simpara>Here are some vectors and possible translations:</simpara>
<simpara>image:imgs/chapter01_3-01.png</simpara>
<simpara>(  3, 5) —&gt; Walk three steps east, turn and walk five steps north.
(  2,-1) —&gt; Walk two steps east, turn and walk one step south.
(-15, 3) —&gt; Walk fifteen steps west, turn and walk three steps north.</simpara>
<simpara>You’ve probably done this before when programming motion.  For every frame of animation (i.e.  a single cycle through Processing’s <emphasis role="strong"><phrase role="function">draw()</phrase></emphasis> loop), you instruct each object on the screen to move a certain number of pixels horizontally and a certain number of pixels vertically.</simpara>
<simpara>image:imgs/chapter01_4-01.png</simpara>
<simpara>For every frame:</simpara>
<simpara><emphasis role="strong"><emphasis>new location = velocity applied to current location</emphasis></emphasis></simpara>
<simpara>If velocity is a vector (the difference between two points), what is location?   Is it a vector too?  Technically, one might argue that location is not a vector, since it’s not describing how to move from one point to another—it’s simply describing a singular point in space.  And so conceptually, we think of a location as different.</simpara>
<simpara>image:imgs/chapter01_5-01.png</simpara>
<simpara>image:imgs/chapter01_6-01.png</simpara>
<simpara><emphasis role="strong"><phrase role="note to self">CONSIDER COMBINING / INTEGRATING THIS DIAGRAM WITH PREVIOUS ONE BETTER</phrase></emphasis></simpara>
<simpara>Nevertheless, another way to describe a location is the path taken from the origin to reach that location. Hence, a location can be the vector representing the difference between location and origin.</simpara>
<simpara>Let’s examine the underlying data for both location and velocity.  In the bouncing ball example we had the following:</simpara>
<simpara>location —&gt; <emphasis role="strong"><phrase role="var">x</phrase></emphasis>,<emphasis role="strong"><phrase role="var">y
velocity —&gt; [var]*xspeed</phrase></emphasis>,<emphasis role="strong"><phrase role="var">yspeed</phrase></emphasis></simpara>
<simpara>Notice how we are storing the _same data for both_—two floating point numbers, an x and a y. If we were to write a vector class ourselves, we’d start with something rather basic:</simpara>
<programlisting language="java" linenumbering="unnumbered">---
class PVector {</programlisting>
<literallayout class="monospaced">float x;
float y;</literallayout>
<literallayout class="monospaced">PVector(float x_, float y_) {
  x = x_;
  y = y_;
}</literallayout>
<simpara>}
---</simpara>
<simpara>At its core, a <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis> is just a convenient way to store two values (or three, as we’ll see in 3D examples.).</simpara>
<simpara>And so this. . .</simpara>
<programlisting language="java" linenumbering="unnumbered">---
float x = 100;
float y = 100;
float xspeed = 1;
float yspeed = 3.3;
---</programlisting>
<orderedlist numeration="arabic">
<listitem>
<simpara>
. . becomes . . .
</simpara>
</listitem>
</orderedlist>
<programlisting language="java" linenumbering="unnumbered">---
PVector location = new PVector(100,100);
PVector velocity = new PVector(1,3.3);
---</programlisting>
<simpara>Now that we have two vector objects (“location” and “velocity”), we’re ready to implement the algorithm for motion—location = location + velocity.   In Example 1.1, without vectors, we had:</simpara>
<programlisting language="java" linenumbering="unnumbered">---
// Add each speed to each location.
x = x + xspeed;
y = y + yspeed;
---</programlisting>
<simpara>In an ideal world, we would be able to rewrite the above as:</simpara>
<programlisting language="java" linenumbering="unnumbered">---
// Add the velocity vector to the location vector.
[line-through]*location = location + velocity;*
---</programlisting>
<simpara>However, in Processing, the addition operator ‘+’ is reserved for primitive values (integers, floats, etc.) only.  Processing doesn’t know how to add two <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis> objects together any more than it knows how to add two <emphasis role="strong"><emphasis>PFont</emphasis></emphasis> objects or <emphasis role="strong"><emphasis>PImage</emphasis></emphasis> objects.   Fortunately for us, the <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis> class includes functions for common mathematical operations.</simpara>
</section>
<section id="_1_3_vector_addition">
<title>1.3 Vector Addition</title>
<simpara>Before we continue looking at the <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis> class and its <emphasis role="strong"><phrase role="function">add()</phrase></emphasis> method (purely for the sake of learning since it’s already implemented for us in Processing itself), let’s examine vector addition using the notation found in math and physics textbooks</simpara>
<simpara>Vectors are typically written either in boldface type or with an arrow on top.  For the purposes of this book, to distinguish a <emphasis role="strong"><emphasis>vector</emphasis></emphasis> from a <emphasis role="strong">scalar</emphasis> (scalar refers to a single value, such as an integer or a floating point number), we’ll use the arrow notation:</simpara>
<simpara>Vector: <emphasis role="strong"><phrase role="vector">u*￼
Scalar: [var]*x</phrase></emphasis></simpara>
<simpara>Let’s say I have the following two vectors:</simpara>
<simpara>image:imgs/chapter01_7-01.png</simpara>
<simpara>Each vector has two components, an x and a y.  To add two vectors together we simply add both x’s and both y’s.  In other words:</simpara>
<literallayout class="monospaced">[vector]*w* = Vector: [vector]*u* + Vector: [vector]*v*</literallayout>
<simpara>translates to:</simpara>
<literallayout class="monospaced">[vector]*w*~x~ = [var]*u~x~* + [var]*v~x~*
[vector]*w*~y~ = [var]*u~y~* + [var]*v~y~*</literallayout>
<simpara>and therefore:</simpara>
<literallayout class="monospaced">[vector]*w*~x~ =  5 + 3
[vector]*w*~y~ =  2 + 4</literallayout>
<simpara>and therefore:</simpara>
<literallayout class="monospaced">[vector]*w* =  (8,6)</literallayout>
<simpara>image:imgs/chapter01_8-01.png</simpara>
<simpara>Now that we understand how to add two vectors together, we can look at how addition is implemented in the <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis> class itself.    Let’s write a function called <emphasis role="strong"><phrase role="function">add()</phrase></emphasis> that takes as its argument another <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis> object.</simpara>
<programlisting language="java" linenumbering="unnumbered">---
class PVector {</programlisting>
<literallayout class="monospaced">float x;
float y;</literallayout>
<literallayout class="monospaced">PVector(float x_, float y_) {
  x = x_;
  y = y_;
}</literallayout>
<literallayout class="monospaced">  *// New!  A function to add another PVector to this PVector.  Simply add the x components and the y components together.
  void add(PVector v) {
    x = x + v.x;
    y = y + v.y;
  }*
}
---</literallayout>
<simpara>Now that we see how <emphasis role="strong"><phrase role="function">add()</phrase></emphasis> is written inside of <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis>, we can return to the <emphasis role="strong"><emphasis>location + velocity</emphasis></emphasis> algorithm with our bouncing ball example and implement vector addition:</simpara>
<programlisting language="java" linenumbering="unnumbered">---
// Add the current velocity to the location.
[line-through]*location = location + velocity;*
location.add(velocity);
---</programlisting>
<simpara>And here we are, ready to rewrite the bouncing ball example using <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis>.</simpara>
<simpara>====Example 1.2: Bouncing ball with PVector!</simpara>
<programlisting language="java" linenumbering="unnumbered">---
// Instead of a bunch of floats, we now just have two PVector variables.
*_PVector location;_*
*_PVector velocity;_*</programlisting>
<simpara>void setup() {
  size(200,200);
  smooth();
  <emphasis role="strong"><emphasis>location = new PVector(100,100);</emphasis></emphasis>
  <emphasis role="strong"><emphasis>velocity = new PVector(2.5,5);</emphasis></emphasis>
}</simpara>
<simpara>void draw() {
  background(255);</simpara>
<literallayout class="monospaced">*_location.add(velocity);</literallayout>
<literallayout class="monospaced">// We still sometimes need to refer to the individual components of a PVector and can do so using the dot syntax: location.x, velocity.y, etc.
if ((location.x &gt; width) || (location.x &lt; 0)) {
  velocity.x = velocity.x * -1;
}
if ((location.y &gt; height) || (location.y &lt; 0)) {
  velocity.y = velocity.y * -1;
}_*</literallayout>
<literallayout class="monospaced">  stroke(0);
  fill(175);
  *_ellipse(location.x,location.y,16,16);_*
}
---</literallayout>
<simpara>Now, you might feel somewhat disappointed.  After all, this may initially appear to have made the code more complicated than the original version.  While this is a perfectly reasonable and valid critique, it’s important to understand that we haven’t fully realized the power of programming with vectors just yet.   Looking at a simple bouncing ball and only implementing vector addition is just the first step.  As we move forward into a more complex world of multiple objects and multiple <emphasis role="strong"><emphasis>forces</emphasis></emphasis> (Chapter 2), the benefits of <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis> will become more apparent.</simpara>
<simpara>We should, however, make note of an important aspect of the above transition to programming with vectors.  Even though we are using <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis> objects to describe two values—the x and y of location and the x and y of velocity—we still often need to refer to the x and y components of each <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis> individually.  When we go to draw an object in Processing, there’s no means for us to say:</simpara>
<programlisting language="java" linenumbering="unnumbered">---
[line-through]*ellipse(location,16,16);*
---</programlisting>
<simpara>The <emphasis role="strong"><phrase role="function">ellipse()</phrase></emphasis> function does not allow for a <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis> as an argument.  An ellipse can only be drawn with two scalar values, an x coordinate and a y coordinate.  And so we must dig into the <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis> object and pull out the x and y components using object-oriented dot syntax.</simpara>
<programlisting language="java" linenumbering="unnumbered">---
ellipse(location.x,location.y,16,16);
---</programlisting>
<simpara>The same issue arises when testing if the circle has reached the edge of the window, and we need to access the individual components of both vectors: location and velocity.</simpara>
<programlisting language="java" linenumbering="unnumbered">---
if ((location.x &gt; width) || (location.x &lt; 0)) {
  velocity.x = velocity.x * -1;
}
---</programlisting>
<example>
<title>Exercise 1.1</title>
<simpara>Find something you’ve previously made in Processing using separate <emphasis role="strong"><phrase role="var">x</phrase></emphasis> and <emphasis role="strong"><phrase role="var">y</phrase></emphasis> variables and use PVectors instead.</simpara>
</example>
<example>
<title>Exercise 1.2</title>
<simpara>Take any of the walker examples from the introduction and convert it to use PVectors.</simpara>
</example>
<example>
<title>Exercise 1.3</title>
<simpara>Extend the bouncing ball with vectors example into 3D.  Can you get a sphere to bounce around a box?</simpara>
</example>
</section>
<section id="_1_4_more_vector_math">
<title>1.4 More Vector Math</title>
<simpara>Addition was really just the first step.   There are many mathematical operations that are commonly used with vectors.   Below is a comprehensive list of the operations available as functions in the <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis> class.  We’ll go through a few of the key ones now.  As our examples get more and more sophisticated in later chapters, we’ll continue to reveal the details of more functions.</simpara>
<itemizedlist>
<listitem>
<simpara>
[function]*add()*—add vectors
</simpara>
</listitem>
<listitem>
<simpara>
[function]*sub()*—subtract vectors
</simpara>
</listitem>
<listitem>
<simpara>
[function]*mult()*—scale the vector with multiplication
</simpara>
</listitem>
<listitem>
<simpara>
[function]*div()*—scale the vector with division
</simpara>
</listitem>
<listitem>
<simpara>
[function]*mag()*—calculate the magnitude of a vector
</simpara>
</listitem>
<listitem>
<simpara>
[function]*normalize()*—normalize the vector to unit length of 1
</simpara>
</listitem>
<listitem>
<simpara>
[function]*limit()*—limit the magnitude of a vector
</simpara>
</listitem>
<listitem>
<simpara>
[function]*heading2D()*—the heading of a vector expressed as an angle
</simpara>
</listitem>
<listitem>
<simpara>
[function]*rotate()*—rotate a 2D vector by an angle
</simpara>
</listitem>
<listitem>
<simpara>
[function]*dist()*—the Euclidean distance between two vectors (considered as points)
</simpara>
</listitem>
<listitem>
<simpara>
[function]*angleBetween()*—find the angle between two vectors
</simpara>
</listitem>
<listitem>
<simpara>
[function]*dot()*—the dot product of two vectors
</simpara>
</listitem>
<listitem>
<simpara>
[function]*cross()*—the cross product of two vectors (only relevant in three dimensions)
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><phrase role="note to self">[CHECK WHAT NEW ONES I’M ADDING IN 2.0]</phrase></emphasis>
</simpara>
</listitem>
</itemizedlist>
<simpara>Having already covered addition, let’s start with subtraction.  This one’s not so bad; just take the plus sign and replace it with a minus!</simpara>
<simpara><emphasis role="strong"><emphasis>Vector subtraction:</emphasis></emphasis>   <emphasis role="strong"><phrase role="vector">w</phrase></emphasis>=<emphasis role="strong"><phrase role="vector">u</phrase></emphasis> - <emphasis role="strong"><phrase role="vector">v</phrase></emphasis></simpara>
<simpara>translates to:    <emphasis role="strong"><phrase role="vector">w</phrase></emphasis><subscript>x</subscript> = u<subscript>x</subscript> - v<subscript>x</subscript>
                  <emphasis role="strong"><phrase role="vector">w</phrase></emphasis><subscript>y</subscript> = u<subscript>y</subscript> - v<subscript>y</subscript></simpara>
<simpara>and the function inside <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis> therefore looks like:</simpara>
<programlisting language="java" linenumbering="unnumbered">---
void sub(PVector v) {
    x = x - v.x;
    y = y - v.y;
  }
---</programlisting>
<simpara>image:imgs/chapter01_9-01.png</simpara>
<simpara>image:imgs/chapter01_10-01.png</simpara>
<simpara>The following example demonstrates vector subtraction by taking the difference between two points—the mouse location and the center of the window.</simpara>
<simpara>====Example 1-3: Vector subtraction￼</simpara>
<programlisting language="java" linenumbering="unnumbered">---
void setup() {
  size(200,200);
  smooth();
}</programlisting>
<simpara>void draw() {
  background(255);</simpara>
<literallayout class="monospaced">// Two PVectors, one for the mouse location and one for the center of the window.
PVector mouse  = new PVector(mouseX,mouseY);
PVector center = new PVector(width/2,height/2);</literallayout>
<literallayout class="monospaced">// PVector subtraction!
mouse.sub(center);</literallayout>
<literallayout class="monospaced">// Draw a line to represent the vector.
translate(width/2,height/2);
line(0,0,mouse.x,mouse.y);</literallayout>
<simpara>}
---</simpara>
<example>
<title>No Heading</title>
<simpara>Both addition and subtraction with vectors follow the same algebraic rules as with real numbers.</simpara>
<simpara><emphasis role="strong"><emphasis>The commutative rule:</emphasis></emphasis>   <emphasis role="strong"><phrase role="vector">u</phrase></emphasis> + <emphasis role="strong"><phrase role="vector">v*￼ = [vector]*v</phrase></emphasis> + [vector]*u*￼</simpara>
<simpara><emphasis role="strong"><emphasis>The associative rule:</emphasis></emphasis> ￼[vector]<emphasis role="strong">u</emphasis> + (<emphasis role="strong"><phrase role="vector">v</phrase></emphasis> + <emphasis role="strong"><phrase role="vector">w</phrase></emphasis>)  = (￼[vector]<emphasis role="strong">u</emphasis> + <emphasis role="strong"><phrase role="vector">v</phrase></emphasis>) + [vector]*w*￼</simpara>
<simpara>Fancy terminology and symbols aside, this is really quite a simple concept.  We’re just saying that common sense properties of addition apply to vectors as well.</simpara>
<literallayout class="monospaced">*_3 + 2 = 2 + 3_*</literallayout>
<literallayout class="monospaced">*_(3 + 2) + 1 = 3 + (2 + 1)_*</literallayout>
</example>
<simpara>Moving on to multiplication, we have to think a little bit differently.  When we talk about multiplying a vector, what we typically mean is <emphasis role="strong"><emphasis>scaling</emphasis></emphasis> a vector.  In the case that we want to scale a vector to twice its size or one-third of its size (leaving its direction the same), we would say: “Multiply the vector by 2” or “Multiply the vector by 1/3.”   Note we are multiplying a vector by a scalar, a single number, not another vector.</simpara>
<simpara>To scale a vector, we multiply each component (x and y) by a scalar.</simpara>
<simpara><emphasis role="strong"><emphasis>Vector multiplication:</emphasis></emphasis>    <emphasis role="strong"><phrase role="vector">w</phrase></emphasis> = <emphasis role="strong"><phrase role="vector">u</phrase></emphasis> * n</simpara>
<simpara>translates to:    w<subscript>x</subscript> = u<subscript>x</subscript> * n
                  w<subscript>y</subscript> = u<subscript>y</subscript> * n</simpara>
<simpara>Let’s look at an example with vector notation.</simpara>
<literallayout class="monospaced">[vector]*u* = (-3,7)
n = 3</literallayout>
<literallayout class="monospaced">[vector]*w* = [vector]*u* * n
w~x~ = -3 * 3
w~y~ =  7 * 3</literallayout>
<literallayout class="monospaced">[vector]*w* = (-9, 21)</literallayout>
<simpara>The function inside the <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis> class therefore is written as:</simpara>
<programlisting language="java" linenumbering="unnumbered">---
// With multiplication, the components of the vector are multiplied by a number.
void mult(float n) {
   x = x * n;
   y = y * n;
 }
---</programlisting>
<simpara>And implementing multiplication in code is as simple as:</simpara>
<programlisting language="java" linenumbering="unnumbered">---
// This PVector is now three times the size and is equal to (-9,21).
PVector u = new PVector(-3,7);
u.mult(3);
---</programlisting>
<simpara>image:imgs/chapter01_11-01.png</simpara>
<simpara>====Example 1-4: Multiplying a vector</simpara>
<programlisting language="java" linenumbering="unnumbered">---
void setup() {
  size(200,200);
  smooth();
}</programlisting>
<simpara>void draw() {
  background(255);</simpara>
<literallayout class="monospaced">PVector mouse = new PVector(mouseX,mouseY);
PVector center = new PVector(width/2,height/2);
mouse.sub(center);</literallayout>
<literallayout class="monospaced">// Multiplying a vector!  The vector is now half its original size (multiplied by 0.5).
mouse.mult(0.5);</literallayout>
<literallayout class="monospaced">translate(width/2,height/2);
line(0,0,mouse.x,mouse.y);</literallayout>
<simpara>}
---</simpara>
<simpara>image:imgs/chapter01_12-01.png</simpara>
<simpara>Division works just like multiplication—we simply replace the multiplication sign (asterisk) with the division one (forward slash).</simpara>
<programlisting language="java" linenumbering="unnumbered">---
void div(float n) {
  x = x / n;
  y = y / n;
}</programlisting>
<simpara>PVector u = new PVector(8,-4);
u.div(2);
---</simpara>
<simpara>image:imgs/chapter01_13-01.png</simpara>
<simpara>.</simpara>
<informalexample>
<simpara>As with addition, basic algebraic rules of multiplication and division apply to vectors.</simpara>
<simpara>The associative rule:   (<emphasis role="strong"><phrase role="var">n</phrase></emphasis> * <emphasis role="strong"><phrase role="var">m</phrase></emphasis>) <emphasis role="strong">￼[vector]*v</emphasis> = <emphasis role="strong"><phrase role="var">n</phrase></emphasis> * (<emphasis role="strong"><phrase role="var">m</phrase></emphasis> <emphasis role="strong">￼[vector]*v</emphasis>)
The distributive rule with 2 scalars, 1 vector:   (<emphasis role="strong"><phrase role="var">n</phrase></emphasis> * <emphasis role="strong"><phrase role="var">m</phrase></emphasis>) <emphasis role="strong">￼[vector]*v</emphasis> = <emphasis role="strong"><phrase role="var">n</phrase></emphasis> * <emphasis role="strong"><phrase role="vector">v</phrase></emphasis> + <emphasis role="strong"><phrase role="var">m</phrase></emphasis> <emphasis role="strong">￼[vector]*v</emphasis>
The distributive rule with 2 vectors, 1 scalar:   (<emphasis role="strong"><phrase role="vector">u*￼+ [vector]*v</phrase></emphasis>) * <emphasis role="strong"><phrase role="var">n</phrase></emphasis> = <emphasis role="strong"><phrase role="var">n</phrase></emphasis> * <emphasis role="strong"><phrase role="vector">u</phrase></emphasis> + <emphasis role="strong"><phrase role="var">n</phrase></emphasis> * [vector]*v*￼</simpara>
</informalexample>
</section>
<section id="_1_5_vector_magnitude">
<title>1.5 Vector Magnitude</title>
<simpara>Multiplication and division, as we just saw, are means by which the length of the vector can be changed without affecting direction.  Perhaps you’re wondering: “OK, so how do I know what the length of a vector is?  I know the components (<emphasis role="strong"><phrase role="var">x</phrase></emphasis> and <emphasis role="strong"><phrase role="var">y</phrase></emphasis>), but how long (in pixels) is the actual arrow?!”</simpara>
<simpara>image:imgs/chapter01_14-01.png</simpara>
<simpara>.</simpara>
<informalexample>
<simpara>The length or “magnitude” of a vector <emphasis role="strong"><phrase role="vector">v</phrase></emphasis> is often written as: ||￼[vector]<emphasis role="strong">v</emphasis> ||</simpara>
</informalexample>
<simpara>Understanding how to calculate the length (also known as <emphasis role="strong"><emphasis>magnitude</emphasis></emphasis>) of a vector is incredibly useful and important.</simpara>
<simpara>Notice in the above diagram how the vector, drawn as an arrow and two components (<emphasis role="strong"><phrase role="var">x</phrase></emphasis> and <emphasis role="strong"><phrase role="var">y</phrase></emphasis>), creates a right triangle.  The sides are the components and the hypotenuse is the arrow itself.   We’re very lucky to have this right triangle, because once upon a time, a Greek mathematician named Pythagoras developed a lovely formula to describe the relationship between the sides and hypotenuse of a right triangle.</simpara>
<simpara>image:imgs/chapter01_15-01.png</simpara>
<simpara>The Pythagorean theorem: <emphasis role="strong"><phrase role="var">a</phrase></emphasis> squared plus <emphasis role="strong"><phrase role="var">b</phrase></emphasis> squared equals <emphasis role="strong"><phrase role="var">c</phrase></emphasis> squared.</simpara>
<simpara>Armed with this formula, we can now compute the magnitude of <emphasis role="strong"><phrase role="vector">v</phrase></emphasis> as follows:</simpara>
<itemizedlist>
<listitem>
<simpara>
|| <emphasis role="strong"><phrase role="vector">v</phrase></emphasis> || = <emphasis role="strong"><emphasis>sqrt (v<subscript>x</subscript> * v<subscript>x</subscript> + v<subscript>y</subscript> * v<subscript>y</subscript>)</emphasis></emphasis>
</simpara>
</listitem>
</itemizedlist>
<simpara>or in <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis>:</simpara>
<programlisting language="java" linenumbering="unnumbered">---
float mag() {
  return sqrt(x*x + y*y);
}
---</programlisting>
<simpara>====Example 1-5: Vector magnitude</simpara>
<simpara>image:imgs/chapter01_15-01.png</simpara>
<programlisting language="java" linenumbering="unnumbered">---
void setup() {
  size(200,200);
  smooth();
}</programlisting>
<simpara>void draw() {
  background(255);</simpara>
<literallayout class="monospaced">PVector mouse = new PVector(mouseX,mouseY);
PVector center = new PVector(width/2,height/2);
mouse.sub(center);</literallayout>
<literallayout class="monospaced">// The magnitude (i.e. length) of a vector can be accessed via the mag() function.  Here it is used as the width of a rectangle drawn at the top of the window.
float m = mouse.mag();
fill(0);
rect(0,0,m,10);</literallayout>
<literallayout class="monospaced">translate(width/2,height/2);
line(0,0,mouse.x,mouse.y);</literallayout>
<simpara>}
---</simpara>
</section>
<section id="_1_6_normalizing_vectors">
<title>1.6 Normalizing Vectors</title>
<simpara>Calculating the magnitude of a vector is only the beginning.  The magnitude function opens the door to many possibilities, the first of which is <emphasis role="strong"><emphasis>normalization</emphasis></emphasis>.  Normalizing refers to the process of making something “standard” or, well, “normal.”  In the case of vectors, let’s assume for the moment that a standard vector has a length of one.  To normalize a vector, therefore, is to take a vector of any length and, keeping it pointing in the same direction, change its length to one, turning it into what is called a <emphasis role="strong"><emphasis>unit vector</emphasis></emphasis>.</simpara>
<simpara>image:imgs/chapter01_17-01.png</simpara>
<simpara>The ability to quickly access the unit vector is useful since it describes a vector’s direction without regard to length, and we’ll see this come in handy once we start to work with forces in Chapter 2.</simpara>
<simpara>For any given vector <emphasis role="strong"><phrase role="vector">u</phrase></emphasis>, its unit vector (written as û) is calculated as follows:</simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>var]*û*</emphasis></emphasis> = <emphasis role="strong"><phrase role="vector">u</phrase></emphasis> / || [vector]*u*￼||
</simpara>
</listitem>
</itemizedlist>
<simpara>In other words, to normalize a vector, simply divide each component by its magnitude.  This is pretty intuitive.  Say a vector is of length 5.  Well, 5 divided by 5 is 1.  So looking at our right triangle, we then need to scale the hypotenuse down by dividing by 5.   In that process the sides shrink, divided by 5 as well.</simpara>
<simpara>image:imgs/chapter01_18-01.png</simpara>
<simpara>In the PVector class, we therefore write our normalization function as follows:</simpara>
<programlisting language="java" linenumbering="unnumbered">---
void normalize() {
  float m = mag();
  div(m);
}
---</programlisting>
<simpara>Of course, there’s one small issue.  What if the magnitude of the vector is zero?  We can’t divide by zero!   Some quick error checking will fix that right up:</simpara>
<programlisting language="java" linenumbering="unnumbered">---
void normalize() {
 float m = mag();
 if (m != 0) {
   div(m);
 }
}
---</programlisting>
<simpara>image:imgs/chapter01_19-01.png</simpara>
<simpara>====Example 1-6: Normalizing a vector</simpara>
<programlisting language="java" linenumbering="unnumbered">---
void draw() {
  background(255);</programlisting>
<literallayout class="monospaced">PVector mouse = new PVector(mouseX,mouseY);
PVector center = new PVector(width/2,height/2);
mouse.sub(center);</literallayout>
<literallayout class="monospaced">// In this example, after the vector is normalized it is multiplied by 50 so that it is viewable onscreen. Note that no matter where the mouse is, the vector will have the same length (50) due to the normalization process.
mouse.normalize();
mouse.mult(50);
translate(width/2,height/2);
line(0,0,mouse.x,mouse.y);</literallayout>
<simpara>}
---</simpara>
</section>
<section id="_1_7_vector_motion_velocity">
<title>1.7 Vector Motion: Velocity</title>
<simpara>Why should we care?  Yes, all this vector math stuff sounds like something we should know about, but why exactly?  How will it actually help us write code?   The truth of the matter is that we need to have some patience.  The awesomeness of using the <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis> class will take some time to fully come to light.  This is actually quite common when first learning a new data structure.   For example, when you first learn about an array, it might seem like much more work to use an array than to just have several variables stand for multiple things.   But that plan quickly breaks down when you need a hundred, or a thousand, or ten thousand things.  The same can be true for <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis>.  What might seem like more work now will pay off later, and pay off quite nicely.  And you don’t have to wait too long, as your reward will come in the next chapter.</simpara>
<simpara>For now, however, we want to focus on simplicity.  What does it mean to program motion using vectors?   We’ve seen the beginning of this in Example 1.2 <emphasis role="strong"><emphasis>[REF]</emphasis></emphasis>: the bouncing ball.   An object on screen has a location (where it is at any given moment) as well as a velocity (instructions for how it should move from one moment to the next).   Velocity is added to location:</simpara>
<programlisting language="java" linenumbering="unnumbered">---
location.add(velocity);
---</programlisting>
<simpara>And then we draw the object at that location:</simpara>
<programlisting language="java" linenumbering="unnumbered">---
ellipse(location.x,location.y,16,16);
---</programlisting>
<simpara>This is Motion 101.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
<emphasis role="strong"><emphasis>Add velocity to location</emphasis></emphasis>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>Draw object at location</emphasis></emphasis>
</simpara>
</listitem>
</orderedlist>
<simpara>In the bouncing ball example, all of this code happened in Processing’s main tab, within <emphasis role="strong"><phrase role="function">setup()</phrase></emphasis> and <emphasis role="strong"><phrase role="function">draw()</phrase></emphasis>.   What we want to do now is move towards encapsulating all of the logic for motion inside of a <emphasis role="strong"><emphasis>class</emphasis></emphasis>. This way, we can create a foundation for programming moving objects in Processing.    In <emphasis role="strong"><emphasis>[REF]</emphasis></emphasis> Section  section I.2 of the introduction, “The Random Walker Class,” we briefly reviewed the basics of object-oriented-programming (“OOP”).   Beyond that short introduction, this book assumes experience with objects and classes in Processing.   If you need a refresher, I encourage you to check out the online OOP Processing tutorial: <ulink url="http://processing.org/learning/tutorials/objects/">Processing objects tutorial</ulink>.</simpara>
<simpara>In this case, we’re going to create a generic <emphasis>Mover</emphasis> class, a class to describe a thing moving around the screen.  And so we must consider the following two questions:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
<emphasis role="strong"><emphasis>What data does a Mover have?</emphasis></emphasis>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>What functionality does a Mover have?</emphasis></emphasis>
</simpara>
</listitem>
</orderedlist>
<simpara>Our “Motion 101” algorithm tells us the answers to these questions.  A Mover object has two pieces of data: location and velocity, two PVector objects.</simpara>
<programlisting language="java" linenumbering="unnumbered">---
class Mover {</programlisting>
<literallayout class="monospaced">  PVector location;
  PVector velocity;
---</literallayout>
<simpara>Its functionality is just about as simple.  The Mover needs to move and it needs to be seen.  We’ll implement these as functions named <emphasis role="strong"><phrase role="function">update()</phrase></emphasis> and <emphasis role="strong"><phrase role="function">display()</phrase></emphasis>.  <emphasis role="strong"><phrase role="function">update()</phrase></emphasis> is where we’ll put all of our motion logic code and <emphasis role="strong"><phrase role="function">display()</phrase></emphasis> is where we will draw the object.</simpara>
<programlisting language="java" linenumbering="unnumbered">---
  void update() {
    // The Mover moves.
    location.add(velocity);
  }</programlisting>
<literallayout class="monospaced">void display() {
  stroke(0);
  fill(175);
  // The Mover is displayed.
  ellipse(location.x,location.y,16,16);
}</literallayout>
<simpara>}
---</simpara>
<simpara>We’ve forgotten one crucial item, however: the object’s <emphasis role="strong"><emphasis>constructor</emphasis></emphasis>.  The constructor is a special function inside of a class that creates the instance of the object itself. It is where you give instructions on how to set up the object.  It always has the same name as the class and is called by invoking the <emphasis role="strong"><emphasis>new</emphasis></emphasis> operator: “Mover <emphasis role="strong"><phrase role="var">m</phrase></emphasis> = new <emphasis role="strong"><phrase role="function">Mover( );</phrase></emphasis> ”.</simpara>
<simpara>In our case, let’s arbitrarily decide to initialize our mover object by giving it a random location and a random velocity.</simpara>
<programlisting language="java" linenumbering="unnumbered">---
  Mover() {
    location = new PVector(random(width),random(height));
    velocity = new PVector(random(-2,2),random(-2,2));
  }
---</programlisting>
<simpara>If object-oriented programming is at all new to you, one aspect here may seem a bit confusing.  After all, we spent the beginning of this chapter discussing the <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis> class.  The <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis> class is the template for making the object “location” and the object “velocity”.  So what are they doing inside of yet another object, the Mover object?   In fact, this is just about the most normal thing ever.  An object is simply something that holds data (and functionality).  That data can be numbers (integers, floats, etc.) or other objects!  We’ll see this over and over again in this book.   For example, in Chapter 4 <emphasis role="strong"><emphasis>[REF]</emphasis></emphasis>, we’ll write a class to describe a system of particles.  That “ParticleSystem” object will have as its data a list of Particle objects. . .and each Particle object will have as its data several PVector objects!</simpara>
<simpara>Let’s finish off the Mover class by incorporating a function to determine what the object should do when it reaches the edge of the window.  For now let’s do something simple, and just have it wrap around the edges.</simpara>
<programlisting language="java" linenumbering="unnumbered">---
  void checkEdges() {</programlisting>
<literallayout class="monospaced">// When it reaches one edge, set location to the other.
if (location.x &gt; width) {
  location.x = 0;
} else if (location.x &lt; 0) {
  location.x = width;
}</literallayout>
<literallayout class="monospaced">if (location.y &gt; height) {
  location.y = 0;
} else if (location.y &lt; 0) {
  location.y = height;
}</literallayout>
<literallayout class="monospaced">  }
---</literallayout>
<simpara>Now that the Mover class is finished, we can look at what we need to do in our main program.  We first declare a Mover object:</simpara>
<programlisting language="java" linenumbering="unnumbered">---
Mover mover;
---</programlisting>
<simpara>Then initialize the mover in <emphasis role="strong"><phrase role="function">setup()</phrase></emphasis>:</simpara>
<programlisting language="java" linenumbering="unnumbered">---
mover = new Mover();
---</programlisting>
<simpara>and call the appropriate functions in <emphasis role="strong"><phrase role="function">draw()</phrase></emphasis>:</simpara>
<programlisting language="java" linenumbering="unnumbered">---
mover.update();
mover.checkEdges();
mover.display();
---</programlisting>
<simpara>Here is the entire example for reference:</simpara>
<simpara>image:imgs/chapter01_20-01.png</simpara>
<simpara>====Example 1.7: Motion 101 (velocity)￼</simpara>
<programlisting language="java" linenumbering="unnumbered">---
Mover mover;      // Declare Mover object.</programlisting>
<simpara>void setup() {
  size(200,200);
  smooth();
  background(255);
  mover = new Mover();  // Create Mover object.
}</simpara>
<simpara>void draw() {
  background(255);</simpara>
<literallayout class="monospaced">  mover.update();   // Call functions on Mover object.
  mover.checkEdges();
  mover.display();
}</literallayout>
<simpara>class Mover {</simpara>
<literallayout class="monospaced">PVector location;   // Our object has two PVectors: location and velocity.
PVector velocity;</literallayout>
<literallayout class="monospaced">Mover() {
  location = new PVector(random(width),random(height));
  velocity = new PVector(random(-2,2),random(-2,2));
}</literallayout>
<literallayout class="monospaced">void update() {
  location.add(velocity); // Motion 101: Location changes by velocity.
}</literallayout>
<literallayout class="monospaced">void display() {
  stroke(0);
  fill(175);
  ellipse(location.x,location.y,16,16);
}</literallayout>
<literallayout class="monospaced">void checkEdges() {
  if (location.x &gt; width) {
    location.x = 0;
  } else if (location.x &lt; 0) {
    location.x = width;
  }</literallayout>
<literallayout class="monospaced">    if (location.y &gt; height) {
      location.y = 0;
    } else if (location.y &lt; 0) {
      location.y = height;
    }
  }
}
---</literallayout>
</section>
<section id="_1_8_vector_motion_acceleration">
<title>1.8 Vector Motion: Acceleration</title>
<simpara>OK. At this point, we should feel comfortable with two things: (1) what a <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis> is and (2) how we use <emphasis role="strong"><emphasis>PVectors</emphasis></emphasis> inside of an object to keep track of its location and movement.  This is an excellent first step and deserves a mild round of applause.   Before standing ovations and screaming fans, however, we need to make one more, somewhat larger, step forward.   After all, watching the Motion 101 example is fairly boring—the circle never speeds up, never slows down, and never turns.  For more interesting motion, for motion that appears in the real world around us, we need to add one more <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis> to our class—<emphasis role="strong"><emphasis>acceleration</emphasis></emphasis>.</simpara>
<simpara>The strict definition of acceleration we’re using here is: the rate of <emphasis>change of velocity</emphasis>.  Let’s think about that definition for a moment.  Is this a new concept?  Not really.  Velocity is defined as <emphasis>the rate of change of location</emphasis>.  In essence, we are developing a “trickle down” effect.  Acceleration affects velocity, which in turn affects location (for some brief foreshadowing, this point will become even more crucial in the next chapter when we see how forces affect acceleration, which affects velocity, which affects location.)  In code, this reads:</simpara>
<programlisting language="java" linenumbering="unnumbered">---
velocity.add(acceleration);
location.add(velocity);
---</programlisting>
<simpara>As an exercise, from this point forward, let’s make a rule for ourselves.  Let’s write every example in the rest of this book without ever touching the value of velocity and location (except to initialize them).  In other words, our goal now for programming motion is as follows—come up with an algorithm for how we calculate acceleration and let the trickle-down effect work its magic.   (In truth, you’ll find reasons to break this rule, but it’s important to illustrate the principles behind our motion algorithm.)  And so we need to come up with some ways to calculate acceleration:</simpara>
<simpara>*ACCELERATION ALGORITHMS!</simpara>
<simpara>1) A constant acceleration
2) A totally random acceleration
3) Acceleration towards the mouse*</simpara>
<simpara>Algorithm #1, a constant acceleration, is not particularly interesting, but it is the simplest and will help us begin incorporating acceleration into our code.   The first thing we need to do is add another <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis> to the Mover class:</simpara>
<programlisting language="java" linenumbering="unnumbered">---
class Mover {</programlisting>
<literallayout class="monospaced">  PVector location;
  PVector velocity;
  // A new PVector for acceleration
  PVector acceleration;
---</literallayout>
<simpara>And incorporate acceleration into the <emphasis role="strong"><phrase role="function">update()</phrase></emphasis> function:</simpara>
<programlisting language="java" linenumbering="unnumbered">---
 void update() {
    // Our motion algorithm is now two lines of code!
    velocity.add(acceleration);
    location.add(velocity);
  }
---</programlisting>
<simpara>We’re almost done.  The only missing piece is initialization in the constructor.</simpara>
<programlisting language="java" linenumbering="unnumbered">---
 Mover() {
---</programlisting>
<simpara>Let’s start the mover object in the middle of the window. . .</simpara>
<programlisting language="java" linenumbering="unnumbered">---
 location = new PVector(width/2,height/2);
---</programlisting>
<orderedlist numeration="arabic">
<listitem>
<simpara>
. . with an initial velocity of zero.
</simpara>
</listitem>
</orderedlist>
<programlisting language="java" linenumbering="unnumbered">---
 velocity = new PVector(0,0);
---</programlisting>
<simpara>This means that when the sketch starts, the object is at rest.  We don’t have to worry about velocity anymore as we are controlling the object’s motion entirely with acceleration.  Speaking of which, according to Algorithm #1, our first sketch involves constant acceleration.  So let’s pick a value.</simpara>
<programlisting language="java" linenumbering="unnumbered">---
    acceleration = new PVector(-0.001,0.01);
  }
---</programlisting>
<simpara>Maybe you’re thinking, “Gosh, those values seem awfully small!”   That’s right, they are quite tiny.  It’s important to realize that our acceleration values (measured in pixels) accumulate over time in the velocity, about thirty times per second depending on our sketch’s frame rate.   And so to keep the magnitude of the velocity vector within a reasonable range, our acceleration values should remain quite small.   We can also help this cause by incorporating the <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis> function <emphasis role="strong"><phrase role="function">limit()</phrase></emphasis>.</simpara>
<programlisting language="java" linenumbering="unnumbered">---
// The limit() function constrains the magnitude of a vector.
velocity.limit(10);
---</programlisting>
<simpara>This translates to the following:</simpara>
<simpara><emphasis>What is the magnitude of velocity?  If it’s less than 10, no worries; just leave it as is.  If it’s more than 10, however, reduce it to 10!</emphasis></simpara>
<example>
<title>Exercise 1-4</title>
<simpara>Write the <emphasis role="strong"><phrase role="function">limit()</phrase></emphasis> function for the PVector class.</simpara>
<simpara>void limit(float max) {
    if (<emphasis><emphasis></emphasis>_</emphasis> &gt; <emphasis><emphasis></emphasis>_</emphasis>) {
      <emphasis><emphasis></emphasis></emphasis><emphasis><emphasis>();
      </emphasis>_</emphasis>(max);
    }
  }</simpara>
</example>
<simpara>Let’s take a look at the changes to the Mover class, complete with <emphasis role="strong"><phrase role="function">acceleration</phrase></emphasis> and <emphasis role="strong"><phrase role="function">limit()</phrase></emphasis>.</simpara>
<simpara>image:imgs/chapter01_21-01.png</simpara>
<simpara>====Example 1.8: Motion 101 (velocity and constant acceleration)</simpara>
<programlisting language="java" linenumbering="unnumbered">---
￼class Mover {</programlisting>
<literallayout class="monospaced">PVector location;
PVector velocity;
PVector acceleration; // Acceleration is the key!
float topspeed;     // The variable, topspeed, will limit
         the magnitude of velocity.</literallayout>
<literallayout class="monospaced">Mover() {
  location = new PVector(width/2,height/2);
  velocity = new PVector(0,0);
  acceleration = new PVector(-0.001,0.01);
  topspeed = 10;
}</literallayout>
<literallayout class="monospaced">void update() {
  velocity.add(acceleration); // Velocity changes by acceleration
  velocity.limit(topspeed);      and is limited by topspeed.
  location.add(velocity);
}</literallayout>
<literallayout class="monospaced">// display() is the same</literallayout>
<literallayout class="monospaced">// checkEdges() is the same</literallayout>
<simpara>}
---</simpara>
<example>
<title>Exercise 1-4</title>
<simpara>Create a simulation of a car (or runner) that accelerates when you press the up key and brakes when you press the down key.</simpara>
</example>
<simpara>Now to Algorithm #2,“a totally random acceleration.”  In this case, instead of initializing acceleration in the object’s constructor, we want to pick a new acceleration each cycle, i.e. each time <emphasis role="strong"><phrase role="function">update()</phrase></emphasis> is called.</simpara>
<simpara>image:imgs/chapter01_22-01.png</simpara>
<simpara>====Example 1.9: Motion 101 (velocity and random acceleration)￼</simpara>
<programlisting language="java" linenumbering="unnumbered">---
  void update() {</programlisting>
<literallayout class="monospaced">acceleration = new PVector(random(-1,1),random(-1,1));
acceleration.normalize();</literallayout>
<literallayout class="monospaced">    velocity.add(acceleration);
    velocity.limit(topspeed);
    location.add(velocity);
  }
---</literallayout>
<simpara>While normalizing acceleration is not entirely necessary, it does prove useful, as it standardizes the magnitude of the vector, allowing us to try different things. Such as:</simpara>
<simpara>(a) scaling the acceleration to a constant value</simpara>
<programlisting language="java" linenumbering="unnumbered">---
acceleration = new PVector(random(-1,1),random(-1,1));
acceleration.normalize();
*acceleration.mult(0.5);*
---</programlisting>
<simpara>(b) scaling the acceleration to a random value</simpara>
<programlisting language="java" linenumbering="unnumbered">---
acceleration = new PVector(random(-1,1),random(-1,1));
acceleration.normalize();
*acceleration.mult(random(2));*
---</programlisting>
<simpara>While this may seem like an obvious point, it’s crucial to understand that acceleration does not merely refer to the <emphasis>speeding up</emphasis> or <emphasis>slowing down</emphasis> of a moving object, but rather <emphasis>any change</emphasis> in velocity in either magnitude or direction.   Acceleration is used to steer an object, and we’ll see this again and again in future chapters as we begin to program objects that make decisions about how to move about the screen.</simpara>
<example>
<title>Exercise 1-5</title>
<simpara>Referring back to section I.6 of the Introduction <emphasis role="strong">[REF]</emphasis>, implement acceleration according to Perlin noise.</simpara>
</example>
</section>
<section id="_1_9_static_vs_non_static_functions">
<title>1.9 Static vs. Non-Static Functions</title>
<simpara>Before we get to acceleration Algorithm #3 (accelerate towards the mouse), we need to cover one more rather important aspect of working with vectors and the <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis> class: the difference between using <emphasis role="strong">static</emphasis> methods and <emphasis role="strong">non-static</emphasis> methods.</simpara>
<simpara>Forgetting about vectors for a moment, take a look at the following code:</simpara>
<programlisting language="java" linenumbering="unnumbered">---
float x = 0;
float y = 5;</programlisting>
<simpara>x = x + y;
---</simpara>
<simpara>Pretty simple, right?  <emphasis role="strong"><phrase role="var">x</phrase></emphasis> has the value of 0, we add <emphasis role="strong"><phrase role="var">y</phrase></emphasis> to it, and now <emphasis role="strong"><phrase role="var">x</phrase></emphasis> is equal to 5.  We could write the corresponding code pretty easily based on what we’ve learned about <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis>.</simpara>
<programlisting language="java" linenumbering="unnumbered">---
PVector v = new PVector(0,0);
PVector u = new PVector(4,5);
v.add(u);
---</programlisting>
<simpara>The vector <emphasis role="strong"><phrase role="var">v</phrase></emphasis> has the value of (0,0), we add <emphasis role="strong"><phrase role="var">u</phrase></emphasis> to it, and now <emphasis role="strong"><phrase role="var">v</phrase></emphasis> is equal to (4,5).  Easy, right?</simpara>
<simpara>OK, let’s take a look at another example of some simple floating point math:</simpara>
<programlisting language="java" linenumbering="unnumbered">---
float x = 0;
float y = 5;</programlisting>
<simpara>float z = x + y;
---</simpara>
<simpara><emphasis role="strong"><phrase role="var">x</phrase></emphasis> has the value of 0, we add <emphasis role="strong"><phrase role="var">y</phrase></emphasis> to it, and store the result in a new variable <emphasis role="strong"><phrase role="var">z</phrase></emphasis>.   The value of <emphasis role="strong"><phrase role="var">x</phrase></emphasis> does not change in this example (neither does <emphasis role="strong"><phrase role="var">y</phrase></emphasis>)!  This may seem like a trivial point, and one that is quite intuitive when it comes to mathematical operations with floats.   However, it’s not so obvious with mathematical operations in <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis>).  Let’s try to write the code based on what we know so far.</simpara>
<programlisting language="java" linenumbering="unnumbered">---
PVector v = new PVector(0,0);
PVector u = new PVector(4,5);
// Don’t be fooled; this is incorrect!!!
[line-through]*PVector w = v.add(u);*
---</programlisting>
<simpara>The above might seem like a good guess, but it’s just not the way the <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis> class works.   If we look at the definition of <emphasis role="strong"><phrase role="function">add()</phrase></emphasis> . . .</simpara>
<programlisting language="java" linenumbering="unnumbered">---
void add(PVector v) {
    x = x + v.x;
    y = y + v.y;
 }
---</programlisting>
<orderedlist numeration="arabic">
<listitem>
<simpara>
. . we see that this code does not accomplish our goal.  First, it does not return a new <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis> (the return type is “void”) and second, it changes the value of the <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis> upon which it is called.  In order to add two PVector objects together and return the result as a new PVector, we must use the <emphasis role="strong"><phrase role="function">static add()</phrase></emphasis> function.
</simpara>
</listitem>
</orderedlist>
<simpara>Functions that we call from the class name itself (rather than from a speciﬁc object instance) are known as <emphasis role="strong">static</emphasis> functions.   Here are two examples of function calls that assume two PVector objects, <emphasis role="strong"><phrase role="var">v</phrase></emphasis> and <emphasis role="strong"><phrase role="var">u</phrase></emphasis>:</simpara>
<programlisting language="java" linenumbering="unnumbered">---
// Static: called from the class name.
PVector.add(v,u);
// Not static: called from an object instance.
v.add(u);
---</programlisting>
<simpara>Since you can’t write static functions yourself in Processing, you might not have encountered them before.  <emphasis role="strong"><phrase role="class">PVector*’s static functions allow us to perform generic mathematical operations on [class]*PVector</phrase></emphasis> objects without having to adjust the value of one of the input <emphasis role="strong"><emphasis>PVectors</emphasis></emphasis>.  Let’s look at how we might write the static version of <emphasis role="strong"><phrase role="function">add()</phrase></emphasis>:</simpara>
<programlisting language="java" linenumbering="unnumbered">---
  // The static version of add allows us to add two PVectors together and assign the result to a new PVector while leaving the original PVectors (v and u) intact.
  static PVector add(PVector v1, PVector v2) {
    PVector v3 = new PVector(v1.x + v2.x, v1.y + v2.y);
    return v3;
  }
---</programlisting>
<simpara>There are several differences here:</simpara>
<itemizedlist>
<listitem>
<simpara>
The function is labeled as <emphasis role="strong"><emphasis>static</emphasis></emphasis>.
</simpara>
</listitem>
<listitem>
<simpara>
The function does not have a <emphasis role="strong"><emphasis>void</emphasis></emphasis> return type, but rather returns a <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis>.
</simpara>
</listitem>
<listitem>
<simpara>
The function creates a new PVector (v3) and returns the sum of the components of <emphasis role="strong"><phrase role="var">v1</phrase></emphasis> and <emphasis role="strong"><phrase role="var">v2</phrase></emphasis> in that new PVector.
</simpara>
</listitem>
</itemizedlist>
<simpara>When you call a static function, instead of referencing an actual object instance, you simply reference the name of the class itself.</simpara>
<programlisting language="java" linenumbering="unnumbered">---
PVector v = new PVector(0,0);
PVector u = new PVector(4,5);
[line-through]*PVector w = v.add(u);*
*PVector w = PVector.add(v,u);*
---</programlisting>
<simpara>The PVector class has static versions of <emphasis role="strong"><phrase role="function">add()</phrase></emphasis>, <emphasis role="strong"><phrase role="function">sub()</phrase></emphasis>, <emphasis role="strong"><phrase role="function">mult()</phrase></emphasis>, and <emphasis role="strong"><phrase role="function">div()</phrase></emphasis>.</simpara>
<example>
<title>Exercise 1-6</title>
<simpara>Translate the following pseudocode to code using static or non-static functions where appropriate.</simpara>
<itemizedlist>
<listitem>
<simpara>
The PVector [var]*v equals (1,5)
</simpara>
</listitem>
<listitem>
<simpara>
The PVector <emphasis role="strong"><phrase role="var">u</phrase></emphasis> equals <emphasis role="strong"><phrase role="var">v</phrase></emphasis> multiplied by 2.
</simpara>
</listitem>
<listitem>
<simpara>
The PVector <emphasis role="strong"><phrase role="var">w</phrase></emphasis> equals <emphasis role="strong"><phrase role="var">v</phrase></emphasis> minus <emphasis role="strong"><phrase role="var">u</phrase></emphasis>.
</simpara>
</listitem>
<listitem>
<simpara>
Divide the PVector w by 3.
</simpara>
</listitem>
</itemizedlist>
<simpara>PVector <emphasis role="strong"><phrase role="var">v</phrase></emphasis> = new PVector(1,5);
PVector <emphasis role="strong"><phrase role="var">u</phrase></emphasis> = <emphasis><emphasis></emphasis></emphasis><emphasis>.</emphasis><emphasis><emphasis>(</emphasis>,<emphasis>);
PVector <emphasis role="strong"><phrase role="var">w</phrase></emphasis> = </emphasis></emphasis><emphasis><emphasis></emphasis>.<emphasis></emphasis></emphasis>(<emphasis>,</emphasis>);
<emphasis><emphasis></emphasis></emphasis><emphasis>_</emphasis>;</simpara>
</example>
</section>
<section id="_1_10_interactivity_with_acceleration">
<title>1.10 Interactivity with acceleration</title>
<simpara>To finish out this chapter, let’s try something a bit more complex and a great deal more useful.  We’ll dynamically calculate an object’s acceleration according to a rule, acceleration Algorithm #3 —“the object accelerates towards the mouse.”</simpara>
<simpara>image:imgs/chapter01_23-01.png</simpara>
<simpara>Anytime we want to calculate a vector based on a rule or a formula, we need to compute two things: <emphasis role="strong"><emphasis>magnitude</emphasis></emphasis> and <emphasis role="strong"><emphasis>direction</emphasis></emphasis>.  Let’s start with direction.  We know the acceleration vector should point from the object’s location towards the mouse location.  Let’s say the object is located at the point (<emphasis role="strong"><phrase role="var">x</phrase></emphasis>,<emphasis role="strong"><phrase role="var">y</phrase></emphasis>) and the mouse at (<emphasis role="strong"><phrase role="var">mouseX</phrase></emphasis>,<emphasis role="strong"><phrase role="var">mouseY</phrase></emphasis>).</simpara>
<simpara>image:imgs/chapter01_24-01.png</simpara>
<simpara>As illustrated in the above diagram, we see that we can get a vector (<emphasis role="strong"><phrase role="var">dx</phrase></emphasis>,<emphasis role="strong"><phrase role="var">dy</phrase></emphasis>) by subtracting the object’s location from the mouse’s location.</simpara>
<simpara><emphasis role="strong">[var]*dx</emphasis> = <emphasis role="strong"><phrase role="var">mouseX</phrase></emphasis> - <emphasis role="strong"><phrase role="var">x<emphasis role="strong">
*[var]*dy</phrase></emphasis> = <emphasis role="strong"><phrase role="var">mouseY</phrase></emphasis> - [var]*y</emphasis></simpara>
<simpara>Let’s rewrite the above using <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis> syntax.   Assuming we are in the Mover class and thus have access to the object’s location <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis>, we then have:</simpara>
<programlisting language="java" linenumbering="unnumbered">---
PVector mouse = new PVector(mouseX,mouseY);
// Look! We’re using the static reference to sub() because we want a new PVector pointing from one point to another.
PVector dir = PVector.sub(mouse,location);
---</programlisting>
<simpara>We now have a <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis> that points from the mover’s location all the way to the mouse.  If the object were to actually accelerate using that vector, it would appear instantaneously at the mouse location.  This does not make for good animation, of course, and what we want to do now is decide how quickly that object should accelerate toward the mouse.</simpara>
<simpara>In order to set the magnitude (whatever it may be) of our acceleration PVector, we must first <emphasis><emphasis></emphasis>__</emphasis> that direction vector.  That’s right, you said it.  <emphasis role="strong"><emphasis>Normalize</emphasis></emphasis>.   If we can shrink the vector down to its unit vector (of length one) then we have a vector that tells us the direction and can easily be scaled to any value.   One multiplied by anything equals anything.</simpara>
<programlisting language="java" linenumbering="unnumbered">---
float anything = ?????
dir.normalize();
dir.mult(anything);
---</programlisting>
<simpara>To summarize, we take the following steps:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
Calculate a vector that points from the object to the target location (mouse).
</simpara>
</listitem>
<listitem>
<simpara>
Normalize that vector (reducing its length to 1)
</simpara>
</listitem>
<listitem>
<simpara>
Scale that vector to an appropriate value (by multiplying it by some value)
</simpara>
</listitem>
<listitem>
<simpara>
Assign that vector to acceleration
</simpara>
</listitem>
</orderedlist>
<simpara>And here are those steps in the <emphasis role="strong"><emphasis>update()</emphasis></emphasis> function itself:</simpara>
<simpara>image:imgs/chapter01_25-01.png</simpara>
<programlisting language="java" linenumbering="unnumbered">---
 void update() {</programlisting>
<literallayout class="monospaced">PVector mouse = new PVector(mouseX,mouseY);
// Step 1: Direction
PVector dir = PVector.sub(mouse,location);</literallayout>
<literallayout class="monospaced">// Step 2: Normalize
dir.normalize();</literallayout>
<literallayout class="monospaced">// Step 3: Scale
dir.mult(0.5);</literallayout>
<literallayout class="monospaced">// Step 4: Accelerate
acceleration = dir;</literallayout>
<literallayout class="monospaced">velocity.add(acceleration);
velocity.limit(topspeed);
location.add(velocity);</literallayout>
<literallayout class="monospaced">  }
---</literallayout>
<simpara>You may be wondering why the circle doesn’t stop when it reaches the target.  It’s important to note that the object moving has no knowledge about trying to stop at a destination; it only knows where the destination is and tries to go there as quickly as possible. Going as quickly as possible means it will inevitably overshoot the location and have to turn around, again going as quickly as possible towards the destination, overshooting it again, and so on, and so forth.   Stay tuned; in later chapters we’ll learn how to program an object to “arrive” at a location (slow down on approach).</simpara>
<example>
<title>Exercise 1-7</title>
<simpara>This example is remarkably close to the concept of gravitational attraction (in which the object is attracted to the mouse location).  Gravitational attraction will be covered in more detail in the next chapter. However, one thing missing here is that the strength of gravity (magnitude of acceleration) is inversely proportional to distance.  This means that the closer the object is to the mouse, the faster it accelerates.   Try implementing the above example with a variable magnitude of acceleration, stronger when it is either closer or farther away.</simpara>
</example>
<simpara>Let’s see what this example would look like with an array of Mover objects (rather than just one).</simpara>
<simpara>image:imgs/chapter01_26-01.png</simpara>
<simpara>====Example 1.10: Accelerating towards mouse</simpara>
<programlisting language="java" linenumbering="unnumbered">---
// An array of objects
Mover[] movers = new Mover[20];</programlisting>
<simpara>void setup() {
  size(200,200);
  smooth();
  background(255);
  for (int i = 0; i &lt; movers.length; i++) {
    // Initialize each object in the array.
    movers[i] = new Mover();
  }
}</simpara>
<simpara>void draw() {
  background(255);</simpara>
<literallayout class="monospaced">  for (int i = 0; i &lt; movers.length; i++) {
    // Calling functions on all the objects in the array.
    movers[i].update();
    movers[i].checkEdges();
    movers[i].display();
  }
}</literallayout>
<simpara>class Mover {
  // Our algorithm for calculating acceleration:
  // find vector pointing towards mouse
  // normalize
  // scale
  // set to acceleration
  PVector location;
  PVector velocity;
  PVector acceleration;
  float topspeed;</simpara>
<literallayout class="monospaced">Mover() {
  location = new PVector(random(width),random(height));
  velocity = new PVector(0,0);
  topspeed = 4;
}</literallayout>
<literallayout class="monospaced">void update() {</literallayout>
<literallayout class="monospaced">PVector mouse = new PVector(mouseX,mouseY);
PVector dir = PVector.sub(mouse,location);
dir.normalize();
dir.mult(0.5);
acceleration = dir;</literallayout>
<literallayout class="monospaced">  // Motion 101! Velocity changes by acceleration.  Location changes by velocity.
  velocity.add(acceleration);
  velocity.limit(topspeed);
  location.add(velocity);
}</literallayout>
<literallayout class="monospaced">void display() {
  stroke(0);
  fill(175);
  ellipse(location.x,location.y,16,16);
}</literallayout>
<literallayout class="monospaced">void checkEdges() {</literallayout>
<literallayout class="monospaced">if (location.x &gt; width) {
  location.x = 0;
} else if (location.x &lt; 0) {
  location.x = width;
}</literallayout>
<literallayout class="monospaced">    if (location.y &gt; height) {
      location.y = 0;
    }  else if (location.y &lt; 0) {
      location.y = height;
    }
  }
}
---</literallayout>
<example>
<title>Ecosystem Project:</title>
<simpara>As mentioned in the preface, one way to use this book is to build a single project over the course of reading it, incorporating elements from each chapter one step at a time.  We’ll follow the development of an example project throughout this book—an “ecosystem” simulation.  Imagine a population of computational creatures swimming around a digital pond, interacting with each other according to various rules.</simpara>
<simpara>Step 1 Exercise:</simpara>
<simpara>Develop a set of rules for simulating the real-world behavior of a creature, such as a nervous fly, swimming fish, hopping bunny, slithering snake, etc.  Can you control the object’s motion by only manipulating the acceleration?  Try to give the creature a personality through its behavior (rather than through its visual design.)</simpara>
</example>
</section>
<blockquote>
<simpara>“Don&#8217;t underestimate the Force.”
        —Darth Vader</simpara>
</blockquote>
<simpara>In the final example of Chapter 1, we saw how we could calculate a dynamic acceleration based on a vector pointing from a circle on the screen to the mouse location.   The resulting motion resembled a magnetic attraction between circle and mouse, as if some <emphasis>force</emphasis> were pulling the circle in towards the mouse.  In this chapter we will formalize our understanding of the concept of a <emphasis role="strong"><emphasis>force</emphasis></emphasis> and its relationship to <emphasis role="strong"><emphasis>acceleration</emphasis></emphasis>.    Our goal, by the end of this chapter, is to understand how to make multiple objects move around the screen and respond to a variety of environmental forces.</simpara>
<section id="_2_1_forces_and_newton_s_laws_of_motion">
<title>2.1 Forces and Newton’s Laws of Motion</title>
<simpara>Before we begin examining the practical realities of simulating forces in code, let’s take a conceptual look at what it means to be a <emphasis role="strong"><emphasis>force</emphasis></emphasis> in the real world.   Just as with the word “vector”, “force” is often commonly used to mean a variety of things.  It can be used to indicate a powerful intensity, as in “She pushed the boulder with great force” or “He spoke forcefully.”   The definition of force that we care about is much more formal and comes from Isaac Newton’s laws of motion:</simpara>
<simpara><emphasis role="strong"><emphasis>Force is a vector that causes an object with mass to accelerate.</emphasis></emphasis></simpara>
<simpara>The good news here is that we recognize the first part of the definition—“a force is a vector.” Thank goodness we just spent a whole chapter learning what a vector is and how to program with PVectors!</simpara>
<simpara>Let’s look at Newton’s three laws in relation to the concept of a force.</simpara>
<section id="_newton_s_first_law">
<title>Newton’s First Law</title>
<simpara>Newton’s first law is commonly stated as:</simpara>
<simpara><emphasis role="strong"><emphasis>An object at rest stays at rest and an object in motion stays in motion.</emphasis></emphasis></simpara>
<simpara>However, this is missing an important element related to forces and so we could expand it by stating:</simpara>
<simpara><emphasis role="strong"><emphasis>An object at rest stays at rest and an object in motion stays in motion at a constant speed and direction unless acted upon by an unbalanced force.</emphasis></emphasis></simpara>
<simpara>By the time Newton came along, the prevailing theory of motion—formulated by Aristotle—was nearly two thousand years old. It stated that if an object is moving, some sort of “force” is required to keep it moving.   Unless that moving thing is being pushed or pulled, it will simply slow down or stop.   Right?</simpara>
<simpara>This, of course, is not true.   In the absence of any forces, no force is required to keep an object moving.  An object (such as a ball) tossed in the earth’s atmosphere slows down because of air resistance (a force).    An object’s velocity will only remain constant in the absence of any forces or if the forces that act on it <emphasis>cancel each other out</emphasis>, i.e. the net force adds up to zero.  This is often referred to as <emphasis role="strong"><emphasis>equilibrium</emphasis></emphasis>.  The falling ball will reach a terminal velocity (that stays constant) once the force of air resistance equals the force of gravity.</simpara>
<simpara>image:imgs/chapter02_1-01.png</simpara>
<simpara>In our Processing world, we could restate Newton’s first law as follows:</simpara>
</section>
<section id="_newton_s_first_law_as_seen_through_the_eyes_of_processing">
<title>Newton’s First Law as seen through the eyes of Processing</title>
<simpara>An object’s PVector <emphasis role="strong"><emphasis>velocity</emphasis></emphasis> will remain constant if it is in a state of equilibrium.</simpara>
<simpara>Skipping Newton’s second law (arguably the most important law for our purposes) for a moment, let’s move on to the third law.</simpara>
</section>
<section id="_newton_s_third_law">
<title>Newton’s Third Law</title>
<simpara>This law is often stated as:</simpara>
<simpara><emphasis role="strong"><emphasis>For every action there is an equal and opposite reaction.</emphasis></emphasis></simpara>
<simpara>This law frequently causes some confusion in the way that it is stated.   For one, it sounds like one force causes another.   Yes, if you push someone, that someone may <emphasis>actively</emphasis> decide to push you back.  But this is not the action and reaction we are talking about with Newton’s third law.</simpara>
<simpara>Let’s say you push against a wall.  The wall doesn’t actively decide to push back on you.   There is no “origin” force.   Your push simply includes both forces, referred to as an “action/reaction pair.”</simpara>
<simpara>A better way of stating the law might be: “Forces always occur in pairs.  The two forces are of equal strength, but in opposite directions.”</simpara>
<simpara>Now, this still causes confusion because it sounds like these forces would always cancel each other out.   This is not the case.  Remember, the forces act on different objects.  And just because the two forces are equal, it doesn’t mean that the <emphasis>movements</emphasis> are equal (or that the objects will stop moving).</simpara>
<simpara>Try pushing on a stationary truck.  Although the truck is far more powerful than you, it will never overpower you.  The force you exert on it is equal and opposite to the force exerted on your hand.   The outcome depends on a variety of other factors.  If the truck is a small truck on an icy downhill, you’ll probably be able to get it to move.  On the other hand, if it’s a very large truck on a dirt road and you push hard enough (maybe even take a running start) you could injure your hand.</simpara>
<simpara>And if you are wearing roller skates when you push on that truck?</simpara>
<simpara>image:imgs/chapter02_2-01.png
￼
<emphasis role="strong"><phrase role="note to self">[REDO DIAGRAM]</phrase></emphasis></simpara>
<simpara>You’ll accelerate away from the truck sliding along the road while the truck stays put.   Why do you slide but not the truck?  For one, the truck has a much larger mass (which we’ll get into with Newton’s second law) and there are other forces at work too, namely the friction of the truck’s tires and your roller skates against the road.</simpara>
</section>
<section id="_newton_s_third_law_as_seen_through_the_eyes_of_processing">
<title>Newton’s Third Law as seen through the eyes of Processing</title>
<simpara>If we calculate a PVector <emphasis role="strong"><phrase role="var"><emphasis>f</emphasis></phrase></emphasis> that is a force of object A on object B, we must also apply the force <emphasis role="strong"><phrase role="var"><emphasis>-f</emphasis></phrase></emphasis>  (or <emphasis role="strong"><emphasis>PVector.mult(f,-1);</emphasis></emphasis>) that B exerts on object A.</simpara>
<simpara>We’ll see that in the world of Processing programming we don’t always have to stay true to the above.  Sometimes, such as in the case of gravitational attraction between bodies ([note to self]see ex. 2.x on p.XX), we’ll want to model equal and opposite forces.  Other times, such as when we’re simply saying, “Hey, there’s some wind in the environment,” we’re not going to bother to model the force that a body exerts back on the air.  In fact, we’re not modeling the air at all!  Remember, we are simply taking inspiration from the physics of the natural world and not simulating everything with perfect precision.</simpara>
</section>
</section>
<section id="_2_2_forces_and_processing_newton_s_second_law_as_a_function">
<title>2.2 Forces and Processing—Newton’s Second Law as a Function</title>
<simpara>And here we are at the most important law for the Processing programmer.</simpara>
<section id="_newton_s_second_law">
<title>Newton’s Second Law</title>
<example>
<title>Weight vs. Mass</title>
<itemizedlist>
<listitem>
<simpara>
The <emphasis role="strong">mass</emphasis> of an object is a measure of the amount of matter in the object (measured in kilograms).
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong">Weight</emphasis>, though often mistaken for mass, is technically the force of gravity on an object. From Newton’s second law, we can calculate it as mass times the acceleration of gravity (<emphasis role="strong"><phrase role="var">w</phrase></emphasis> = <emphasis role="strong"><phrase role="var">m</phrase></emphasis> * <emphasis role="strong"><phrase role="var">g</phrase></emphasis>). Weight is measured in newtons.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong">Density</emphasis> is is defined as the amount of mass per unit of volume (grams per cubic centimeter, for example).
</simpara>
</listitem>
</itemizedlist>
<simpara>Note that an object that has a mass of one kilogram on earth would have a mass of one kilogram on the moon. However, it would weigh only one-sixth as much.</simpara>
</example>
<simpara><emphasis role="strong"><phrase role="var"><emphasis>F</emphasis></phrase></emphasis> = <emphasis role="strong"><phrase role="var"><emphasis>M</emphasis></phrase></emphasis> * <emphasis role="strong"><phrase role="var"><emphasis>A</emphasis></phrase></emphasis>
Force equals mass times acceleration.</simpara>
<simpara><emphasis role="strong"><emphasis>[ADD ARROWS TO THESE FORMULAS FOR VECTORS]</emphasis></emphasis></simpara>
<simpara>Why is this the most important law for us?  Well, let’s write this a different way.</simpara>
<simpara><emphasis role="strong"><phrase role="var"><emphasis>A</emphasis></phrase></emphasis> = <emphasis role="strong"><phrase role="var"><emphasis>F</emphasis></phrase></emphasis> / <emphasis role="strong"><phrase role="var"><emphasis>M</emphasis></phrase></emphasis></simpara>
<simpara>Acceleration is directly proportional to force and inversely proportional to mass.  This means that if you get pushed, the harder you are pushed, the faster you’ll move (accelerate).  The bigger you are, the slower you’ll move.</simpara>
<simpara>Now, in the world of Processing, what is mass anyway?  Aren’t we dealing with pixels?  To start in a simpler place, let’s say that in our pretend pixel world, all of our objects have a mass equal to 1.  <emphasis role="strong"><phrase role="var">F</phrase></emphasis>/ 1 = <emphasis role="strong"><phrase role="var">F</phrase></emphasis>.  And so:</simpara>
<simpara><emphasis role="strong"><phrase role="var">A</phrase></emphasis> = <emphasis role="strong"><phrase role="var">F</phrase></emphasis></simpara>
<simpara>The acceleration of an object is equal to force.  This is great news.  After all, we saw in Chapter 1 that acceleration was the key to the controlling the movement of our objects on screen.  Location is adjusted by velocity, and velocity by acceleration.  Acceleration was where it all began.  Now we learn that <emphasis role="strong">force</emphasis> is truly where it all begins.</simpara>
<simpara>Let’s say we have a class called Mover, with location, velocity, and acceleration.</simpara>
<programlisting language="java" linenumbering="unnumbered">---
class Mover {
  PVector location;
  PVector velocity;
  PVector acceleration;
}
---</programlisting>
<simpara>Now our goal is to be able to add forces to this object, perhaps saying:</simpara>
<programlisting language="java" linenumbering="unnumbered">---
mover.applyForce(wind);
---</programlisting>
<simpara>or:</simpara>
<programlisting language="java" linenumbering="unnumbered">---
mover.applyForce(gravity);
---</programlisting>
<simpara>where wind and gravity are PVectors.  According to Newton’s second law, we could implement this function as follows.</simpara>
<programlisting language="java" linenumbering="unnumbered">---
  void applyForce(PVector force) {
        // Newton’s second law at its simplest.
    acceleration = force;
  }</programlisting>
</section>
</section>
<section id="_2_3_force_accumulation">
<title>2.3 Force Accumulation</title>
<simpara>This looks pretty good.  After all, it’s a literal translation of Newton’s second law (without mass): <emphasis role="strong"><emphasis>Acceleration = Force</emphasis></emphasis>.   Nevertheless, there’s a pretty big problem here.  Let’s return to what we are trying to accomplish: creating a moving object on the screen that responds to wind and gravity.</simpara>
<programlisting language="java" linenumbering="unnumbered">---
mover.applyForce(wind);
mover.applyForce(gravity);
mover.update();
mover.display();
---</programlisting>
<simpara>Ok, let’s <emphasis>be</emphasis> the computer for a moment.  First, we call <emphasis role="strong"><phrase role="function">applyForce()</phrase></emphasis> with wind.  And so the Mover object’s acceleration is now set to the wind PVector.   Second, we call <emphasis role="strong"><phrase role="function">applyForce()</phrase></emphasis> with gravity.  And so the Mover object’s acceleration is now set to the gravity PVector.    Third, we call <emphasis role="strong"><phrase role="function">update()</phrase></emphasis>.  What happens in update?  Acceleration is added to velocity.</simpara>
<programlisting language="java" linenumbering="unnumbered">---
velocity.add(acceleration);
---</programlisting>
<simpara>We’re not going to see any <emphasis>error</emphasis> in Processing, but zoinks!  We’ve got a major problem.  What is the value of acceleration when it is added to velocity?  It is equal to the gravity force.  Wind has been left out!  If we call <emphasis role="strong"><phrase role="function">applyForce()</phrase></emphasis> more than once, it overrides each previous call.   How are we going to handle more than one force?</simpara>
<simpara>The answer is through a process known as <emphasis role="strong"><emphasis>force accumulation</emphasis></emphasis>.  It’s actually very simple; all we need to do is add all of the forces together.  At any given moment, there might be one, two, six, twelve, or three hundred and three forces.  As long as our object knows how to accumulate them, it doesn’t matter how many forces act on it.</simpara>
<programlisting language="java" linenumbering="unnumbered">---
 void applyForce(PVector force) {
        // Newton’s second law but with force accumulation.
  // We now add each force to acceleration, one at a time.
    acceleration.add(force);
 }
---</programlisting>
<simpara>Now, we’re not finished just yet.  There is one more piece to force accumulation.  Since we’re adding all the forces together at any given moment, we have to make sure that we clear acceleration (i.e. set it to zero) before each time <emphasis role="strong"><phrase role="function">update()</phrase></emphasis> is called.   Let’s think about wind for a moment.   Sometimes the wind is very strong, sometimes it’s weak, and sometimes there’s no wind at all.   At any given moment, there might be a huge gust of wind, say, when the user holds down the mouse.</simpara>
<programlisting language="java" linenumbering="unnumbered">---
if (mousePressed) {
  PVector wind = new PVector(0.5,0);
  mover.applyForce(wind);
}
---</programlisting>
<simpara>When the user releases the mouse, the wind will stop and according to Newton’s first law, the object will continue to move at a constant velocity.   However, if we had forgotten to reset acceleration to zero, the gust of wind would still be in effect.  Even worse, it would add onto itself from the previous frame, since we are accumulating forces!    Acceleration, in our simulation, has no memory; it is simply calculated based on the environmental forces present at a moment in time.   This is different than, say, location, which must remember where the object was the previous frame in order to move properly to the next.</simpara>
<simpara>The easiest way to implement clearing the acceleration for each frame is to multiply the <emphasis role="strong"><emphasis>PVector</emphasis></emphasis> by zero at the end of <emphasis role="strong"><phrase role="function">update()</phrase></emphasis>.</simpara>
<literallayout class="monospaced">void update() {
   velocity.add(acceleration);
   location.add(velocity);
   acceleration.mult(0);
}</literallayout>
<example>
<title>Exercise 2-1</title>
<simpara>Using forces, simulate a helium-filled balloon floating upward (and bouncing off the top of a window).  Can you add a wind force which changes over time, perhaps according to Perlin noise?</simpara>
</example>
</section>
<section id="_2_4_dealing_with_mass">
<title>2.4 Dealing with Mass</title>
<simpara>OK. We’ve got one tiny little addition to make before we are done with integrating forces into our Mover class and are ready to look at examples.  After all, Newton’s second law is really <emphasis role="strong"><phrase role="var">F</phrase></emphasis> = <emphasis role="strong"><phrase role="var">M</phrase></emphasis> * <emphasis role="strong"><phrase role="var">A</phrase></emphasis>, not <emphasis role="strong"><phrase role="var">F</phrase></emphasis> = <emphasis role="strong"><phrase role="var">A</phrase></emphasis>.   Incorporating mass is as easy as adding an instance variable to our class, but we need to spend a little more time here because a slight complication will emerge.</simpara>
<simpara>First we just need to add mass.</simpara>
<programlisting language="java" linenumbering="unnumbered">---
class Mover {
  PVector location;
  PVector velocity;
  PVector acceleration;
  float mass;
---</programlisting>
<simpara>Mass is a scalar (float), not a vector, as it’s just one number describing the amount of matter in an object.  We could be fancy about things and compute the area of a shape as its mass, but it’s simpler to begin by saying, “Hey, the mass of this object is&#8230;um, I dunno&#8230;how about 10?”</simpara>
<example>
<title>Units of Measurement</title>
<simpara>Now that we are introducing mass it’s important to make a quick note about units of measurement.  In the real world, things are measured with specific units.  We say that two objects are three meters apart, the baseball is moving at a rate of ninety miles per hour, or this bowling ball has a mass of six kilograms.   As we’ll see later in this book, sometimes we will want to take real-world units into consideration.  However, in this chapter, we’re going to ignore them for the most part.  Our units of measurement are in pixels (“these two circles are one hundred pixels apart”) and frames of animation (“this circle is moving at a rate of two pixels per frame.”)   In the case of mass, there isn’t any unit of measurement for us to use.  We’re just going to make something up.  In this example, we’re arbitrarily picking the number ten.   There is no unit of measurement (you might enjoy inventing a unit of your own, like “1 moog” or “1 yurkle.”)  It should also be noted that, for demonstration purposes, we’ll tie mass to pixels (drawing, say, a circle with a radius of ten).  This will allow us to visualize the mass of an object.   In the real world, however, size does not definitely indicate mass. A small metal ball could have a much higher mass than a large balloon due to its higher density.</simpara>
</example>
<programlisting language="java" linenumbering="unnumbered">---
 Mover() {
    location = new PVector(random(width),random(height));
    velocity = new PVector(0,0);
    acceleration = new PVector(0,0);
    mass = 10.0;
  }
---</programlisting>
<simpara>This isn’t so great since things only become interesting once we have objects with varying mass, but it’ll get us started.  Where does mass come in?  We use it while applying Newton’s second law to our object.</simpara>
<programlisting language="java" linenumbering="unnumbered">---
 void applyForce(PVector force) {
   force.div(mass);
   // Newton’s second law (with force accumulation and mass).
   acceleration.add(force);
 }
---</programlisting>
<simpara>Yet again, even though our code looks quite reasonable, we have a fairly major problem here.  Consider the following scenario with two <emphasis>Mover</emphasis> objects, both being blown away by a wind force.</simpara>
<programlisting language="java" linenumbering="unnumbered">---
Mover m1 = new Mover();
Mover m2 = new Mover();</programlisting>
<simpara>PVector wind = new PVector(1,0);</simpara>
<simpara>m1.applyForce(wind);
m2.applyForce(wind);
---</simpara>
<simpara>Again, let’s <emphasis role="strong">be</emphasis> the computer.  Object <emphasis role="strong"><phrase role="var"><emphasis>m1</emphasis></phrase></emphasis> receives the wind force—(1,0)—divides it by mass (10) and adds it to acceleration.</simpara>
<simpara><emphasis role="strong"><emphasis>m1:</emphasis></emphasis>
wind force is equal to  (1,0)
divided by mass = 10:           (0.1,0)</simpara>
<simpara>OK, moving onto object <emphasis role="strong"><phrase role="var"><emphasis>m2</emphasis></phrase></emphasis>.  It also receives the wind force—(1,0).  Wait.  Hold on a second.  What is the value of wind force?   Taking a closer look, the wind force is actually now—(0.1,0)!!   Do you remember this little tidbit about working with objects?  When you pass an object (in this case a <emphasis role="strong"><emphasis>PVector</emphasis></emphasis>) into a function, you are passing a reference to that object.  It’s not a copy!  So if a function makes a change to that object (which, in this case, it does by dividing by mass) then that object is permanently changed!  But we don’t want <emphasis role="strong"><phrase role="var"><emphasis>m2</emphasis></phrase></emphasis> to receive a force divided by the mass of object <emphasis role="strong"><phrase role="var"><emphasis>m1</emphasis></phrase></emphasis>. We want it to receive that force in its original state—(1,0).  And so we must protect ourselves and make a copy of the PVector f before dividing it by mass.    Fortunately, the <emphasis role="strong"><emphasis>PVector</emphasis></emphasis> class has a convenient method for making a copy—get().  get() returns a new PVector object with the same data.  And so we can revise <emphasis role="strong"><phrase role="function">applyForce()</phrase></emphasis> as follows:</simpara>
<programlisting language="java" linenumbering="unnumbered">---
void applyForce(PVector force) {
  PVector f = force.get();              $$ Making a copy of the PVector before using it!
  f.div(mass);
  acceleration.add(f);
}
---</programlisting>
<simpara>There’s another way we could write the above function, using the static method <emphasis role="strong"><phrase role="function">div()</phrase></emphasis>.   For help with this exercise, review static methods in Chapter 1 ([note to self] see p. XXX).</simpara>
<example>
<title>Exercise 2-2</title>
<simpara>Rewrite the applyForce method using the static method div() instead of get().</simpara>
<simpara>void applyForce(PVector force) {
  PVector f = <emphasis><emphasis></emphasis>_</emphasis>.<emphasis><emphasis>(</emphasis></emphasis><emphasis>,</emphasis>__);
  acceleration.add(f);
}</simpara>
</example>
</section>
<section id="_2_5_creating_forces">
<title>2.5 Creating Forces</title>
<simpara>Let’s take a moment to remind ourselves where we are.  We know what a force is (a vector), and we know how to apply a force to an object (divide it by mass, add it to the object’s acceleration vector).   What are we missing?  Well, we have yet to figure out how we get a force in the first place.  Where do forces come from?</simpara>
<simpara>In this chapter, we’ll look at two methods for creating forces in our Processing world.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
<emphasis role="strong">Make up a force!</emphasis>  After all, you are the programmer, the creator of your world. There’s no reason why you can’t just make up a force and apply it.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong">Model a force!</emphasis>  Yes, forces exist in the real world.  And physics textbooks often contain formulas for these forces.  We can take these formulas, translate them into source code, and model real-world forces in Processing.
</simpara>
</listitem>
</orderedlist>
<simpara>The easiest way to make up a force is just to just pick a number.  Let’s start with the idea of simulating wind.  How about a wind force that points to the right and is fairly weak?  Assuming a Mover object “m”, our code would look like:</simpara>
<programlisting language="java" linenumbering="unnumbered">---
  PVector wind = new PVector(0.01,0);
  m.applyForce(wind);
---</programlisting>
<simpara>The result isn’t terribly interesting, but it is a good place to start.  We create a PVector object, initialize it, and pass it into an object (which in turn will apply it to its own acceleration).
￼
If we wanted to have two forces, perhaps wind and gravity (a bit stronger, pointing down), we might say:</simpara>
<programlisting language="java" linenumbering="unnumbered">---
  PVector wind = new PVector(0.01,0);
  PVector gravity = new PVector(0,0.1);
  m.applyForce(wind);
  m.applyForce(gravity);
---</programlisting>
<simpara>image:imgs/chapter02_3-01.png</simpara>
<simpara>Now we have two forces, pointing in different directions with different magnitudes, both applied to object “<emphasis role="strong"><phrase role="var">m</phrase></emphasis>.”  We’re beginning to get somewhere.  We’ve now built a world for our objects in Processing, an environment to which they can actually respond.</simpara>
<simpara>Let’s look at how we could make this example a bit more exciting with many objects of varying mass.   To do this, we’ll need to do a quick review of object-oriented programming.  Again, we’re not covering all the basics of programming here (for that you can check out any of the intro Processing books listed in the introduction).  However, since the idea of creating a world filled with objects is pretty fundamental to all the examples in this book, it’s worth taking a moment to walk through the steps of going from one object to many.</simpara>
<simpara>This is where we are with the Mover class as a whole.  Notice how it is identical to the Mover class created in Chapter 1, with two additions—<emphasis role="strong"><emphasis>mass</emphasis></emphasis> and a new <emphasis role="strong"><phrase role="function">applyForce()</phrase></emphasis> function.</simpara>
<programlisting language="java" linenumbering="unnumbered">---
class Mover {</programlisting>
<literallayout class="monospaced">PVector location;
PVector velocity;
PVector acceleration;
// The object now has mass!
float mass;</literallayout>
<literallayout class="monospaced">Mover() {
  // And for now, we’ll just set the mass equal to 1 for simplicity.
  mass = 1;
  location = new PVector(30,30);
  velocity = new PVector(0,0);
  acceleration = new PVector(0,0);
}</literallayout>
<literallayout class="monospaced">// Newton’s second law.
void applyForce(PVector force) {
  // Receive a force, divide by mass, and add to acceleration.
  PVector f = PVector.div(force,mass);
  acceleration.add(f);
}</literallayout>
<literallayout class="monospaced">void update() {
  // Motion 101 from Chapter 1
  velocity.add(acceleration);
  location.add(velocity);
  // plus clearing the acceleration each time!
  acceleration.mult(0);
}</literallayout>
<literallayout class="monospaced">void display() {
  stroke(0);
  fill(175);
  // Let’s scale the size of the object according to its mass.
  ellipse(location.x,location.y,mass*16,mass*16);
}</literallayout>
<literallayout class="monospaced">// Somewhat arbitrarily, we are deciding that an object
// bounces when it hits the edges of a window.
void checkEdges() {
  if (location.x &gt; width) {
    location.x = width;
    velocity.x *= -1;
  } else if (location.x &lt; 0) {
    velocity.x *= -1;
    location.x = 0;
  }</literallayout>
<literallayout class="monospaced">    if (location.y &gt; height) {
      velocity.y *= -1;
      location.y = height;
    }
  }
}
---</literallayout>
<simpara>Now that our class is set, we can choose to create, say, one hundred Mover objects with an array.</simpara>
<programlisting language="java" linenumbering="unnumbered">---
Mover[] movers = new Mover[100];
---</programlisting>
<simpara>And then we can initialize all of those Mover objects in <emphasis role="strong"><phrase role="function">setup()</phrase></emphasis> with a loop.</simpara>
<programlisting language="java" linenumbering="unnumbered">---
void setup() {
  for (int i = 0; i &lt; movers.length; i++) {
    movers[i] = new Mover();
  }
}
---</programlisting>
<simpara>But now we have a small issue.  If we refer back to the Mover object’s constructor. . .</simpara>
<programlisting language="java" linenumbering="unnumbered">---
  Mover() {
    mass = 1;
    location = new PVector(30,30);
    velocity = new PVector(0,0);
    acceleration = new PVector(0,0);
  }
---</programlisting>
<orderedlist numeration="arabic">
<listitem>
<simpara>
. .we discover that every Mover object is made exactly the same way.  What we want are Mover objects of varying mass that start at varying locations.  Here is where we need to increase the sophistication of our constructor by adding arguments.
</simpara>
</listitem>
</orderedlist>
<programlisting language="java" linenumbering="unnumbered">---
  Mover(float m, float x , float y) {
    mass = m;
    location = new PVector(x,y);
    velocity = new PVector(0,0);
    acceleration = new PVector(0,0);
  }
---</programlisting>
<simpara>Notice how the mass and location are no longer set to hardcoded numbers, but rather initialized via arguments passed through the constructor.   This means we can create a variety of Mover objects: big ones, small ones, ones that start on the left side of the screen, ones that start on the right, etc.</simpara>
<programlisting language="java" linenumbering="unnumbered">---
// A big Mover on the left side of the window
Mover m1 = new Mover(10,0,height/2);
// A small Mover on the right side of the window
Mover m1 = new Mover(0.1,width,height/2);</programlisting>
<simpara>With an array, however, we want to initialize all of the objects with a loop.</simpara>
<programlisting language="java" linenumbering="unnumbered">---
void setup() {
  for (int i = 0; i &lt; movers.length; i++) {
        // Initializing many “Mover” objects all with random mass (and all starting at 0,0).
    movers[i] = new Mover(random(0.1,5),0,0);
  }
}  
---</programlisting>
<simpara>For each “Mover” created, the mass is set to a random value between 0.1 and 5, the starting x-location is set to 0, and the starting y-location is set to 0.  Certainly, there are all sorts of ways we might choose to initialize the objects; this is just a demonstration of one possibility.</simpara>
<simpara>Once the array of objects is declared, created, and initialized, the rest of the code is simple.  We run through every object, hand them each the forces in the environment, and enjoy the show.</simpara>
<simpara>image:imgs/chapter02_4-01.png
￼</simpara>
<programlisting language="java" linenumbering="unnumbered">---
void draw() {
  background(255);</programlisting>
<literallayout class="monospaced">PVector wind = new PVector(0.01,0);
// Make up two forces.
PVector gravity = new PVector(0,0.1);</literallayout>
<literallayout class="monospaced">  for (int i = 0; i &lt; movers.length; i++) {
    movers[i].applyForce(wind);
    // Loop through all objects and apply both forces to each object.
    movers[i].applyForce(gravity);
    movers[i].update();
    movers[i].display();
    movers[i].checkEdges();
  }
}
---</literallayout>
<simpara>Note how in the above image, the smaller circles reach the right of the window faster than the larger ones.  This is because of our formula: <emphasis role="strong"><emphasis>acceleration = force divided by mass</emphasis></emphasis>.   The larger the mass, the smaller the acceleration.</simpara>
<example>
<title>Exercise 2-3</title>
<simpara>Create an example where instead of objects bouncing off the edge of the wall, an invisible force pushes back on the objects to keep them in the window.  Can you weight the force according to how far the object is from an edge—i.e., the closer it is, the stronger the force?</simpara>
</example>
</section>
<section id="_2_6_gravity_on_earth_and_modeling_a_force">
<title>2.6 Gravity on Earth and Modeling a Force</title>
<simpara>You may have noticed something woefully inaccurate about this last example.  The smaller the circle, the faster it falls.   There is a logic to this; after all, we just stated (according to Newton’s second law) that the smaller the mass, the higher the acceleration.  But this is not what happens in the real world.  If you were to climb to the top of the Leaning Tower of Pisa and drop two balls of different masses, which one will hit the ground first?  According to legend, Galileo performed this exact test in 1589, discovering that they fell with the same acceleration, hitting the ground at the same exact time.  Why is this?   As we will see later in this chapter, the force of gravity is calculated relative to an object’s mass.  The bigger the object, the stronger the force.  So if the force is scaled according to mass, it is cancelled out when acceleration is divided by mass.   We can implement this in our sketch rather easily, by multiplying our “made up” gravity force by mass.</simpara>
<simpara>image:imgs/chapter02_5-01.png
￼</simpara>
<programlisting language="java" linenumbering="unnumbered">---
for (int i = 0; i &lt; movers.length; i++) {</programlisting>
<literallayout class="monospaced">PVector wind = new PVector(0.001,0);
// Scaling gravity by mass to be more accurate
PVector gravity = new PVector(0,0.1*movers[i].mass);
movers[i].applyForce(wind);
movers[i].applyForce(gravity);</literallayout>
<literallayout class="monospaced">    movers[i].update();
    movers[i].display();
    movers[i].checkEdges();
  }
---</literallayout>
<simpara>While the object’s now fall at the same rate, because the strength of the wind force is independent of mass, the smaller objects still accelerate to the right more quickly.</simpara>
<simpara>Making up forces will actually get us quite far.  The world of Processing is a pretend world of pixels and you are its master.  So whatever you deem appropriate to be a force, well by golly, that’s the force it should be.  Nevertheless, there may come a time where you find yourself wondering: “But how does it really all work?”</simpara>
<simpara>Open up any high school physics textbook and you will find some diagrams and formulas describing many different forces—gravity, electromagnetism, friction, tension, elasticity, and more.  In this chapter we’re going to look at two forces—friction and gravity.  The point we’re making here is not that friction and gravity are fundamental forces that you always need to have in your Processing sketches.  Rather, we want to evaluate these two forces as case studies for the following process:</simpara>
<itemizedlist>
<listitem>
<simpara>
Understanding the concept behind a force
</simpara>
</listitem>
<listitem>
<simpara>
Deconstructing the force’s formula into two parts:
</simpara>
</listitem>
<listitem>
<simpara>
How do we compute the force’s direction?
</simpara>
</listitem>
<listitem>
<simpara>
How do we compute the force’s magnitude?
</simpara>
</listitem>
<listitem>
<simpara>
Translating that formula into Processing code that calculates a <emphasis role="strong"><emphasis>PVector</emphasis></emphasis> to be sent through our Mover’s <emphasis role="strong"><phrase role="function">applyForce()</phrase></emphasis> function.
</simpara>
</listitem>
</itemizedlist>
<simpara>If we can follow the above steps with two forces, then hopefully if you ever find yourself Googling “atomic nuclei weak nuclear force” at 3 a.m., you will have the skills to take what you find and adapt it for Processing.</simpara>
</section>
<section id="_2_7_friction">
<title>2.7 Friction</title>
<simpara>Let’s begin with friction and follow our steps:</simpara>
<section id="_what_is_friction">
<title>What is friction?</title>
<simpara>Friction is a “dissipative” force.  A dissipative force is one in which the total energy of a system decreases when an object is in motion.   Let’s say you are driving a car. When you press your foot down on the brake pedal, the car’s brakes use friction to slow down the motion of the tires.  Kinetic energy (motion) is converted into thermal energy (heat).   Whenever two surfaces come into contact, they experience friction.   A complete model of friction would include separate cases for static friction (a body at rest against a surface) and kinetic friction (a body in motion against a surface), but for our purposes, we are going to only look at the kinetic case.</simpara>
</section>
<section id="_what_is_the_formula_for_friction">
<title>What is the formula for friction?</title>
<example>
<title>Dealing with formulae</title>
<simpara>Ok, in a moment we’re going to write out the formula for friction.  This isn’t the first time we’ve seen a formula is this book; we just finished up our discussion of Newton’s second law, F =MA (or force = mass * acceleration).    We didn’t spend a lot of time worrying about this formula, because it’s a nice and simple one.  Nevertheless, it’s a scary world out there.  Just take a look at the equation for a “normal” distribution which we covered (without looking at the formula) in the introduction  ([note to self] see [REF]).</simpara>
<simpara>image:imgs/chapter02_6-01.png</simpara>
<simpara>What we’re seeing here is that formulas like to use a lot of symbols (quite often letters from the Greek alphabet).   Let’s take a look at the formula for friction, which we’re about to cover.</simpara>
<simpara>image:imgs/chapter02_7-01.png
￼
If it’s been a while since you’ve looked at a formula from a math or physics textbook, there are three key points that are important to cover before we move on.</simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>Evaluate the right side, assign to the left side.</emphasis></emphasis>  This is just like in code!  What we’re doing here is evaluating the right side of the equation and assigning it to the left.  In the case above, we want to calculate the force of friction—the left side tells us what we want to calculate and the right side tells us how to do it.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>Are we talking about a vector or a scalar?</emphasis></emphasis>  It’s important for us to realize that in some cases, we’ll be looking at a vector; in others, a scalar.   For example, in this case the force of friction is a vector.  It has a magnitude and direction.  We can see that by the arrow above the word “friction.”  The right side of the equation also has a vector, as indicated by the symbol ￼, which is this case stands for the velocity unit vector.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>When symbols are placed next too each other, we mean for them to be multiplied.</emphasis></emphasis>  The formula above actually has four elements:  -1, -μ, N, and image:imgs/chapter02_8-01.png.  We want to multiply them together and read the formula as:
</simpara>
</listitem>
</itemizedlist>
<simpara>image:imgs/chapter02_9-01.png</simpara>
<simpara>=====================================================================￼</simpara>
<simpara>image:imgs/chapter02_10-01.png</simpara>
<simpara>image:imgs/chapter02_11-01.png</simpara>
<simpara>It’s now up to us to separate this formula into two components that determine the direction of friction as well as the magnitude.  Based on the diagram above, we can see that <emphasis>friction points in the opposite direction of velocity.</emphasis>   In fact, that’s the part of the formula that says -1 * image:imgs/chapter02_12-01.png or negative one times the velocity unit vector.  In Processing, this would mean taking the velocity vector, normalizing it, and multiplying by -1.</simpara>
<programlisting language="java" linenumbering="unnumbered">---
PVector friction = velocity.get();
friction.normalize();
// Let’s figure out the direction of the friction force
// (a unit vector in the opposite direction of velocity).
friction.mult(-1);
---</programlisting>
<simpara>Notice two additional steps here.  First, it’s important to make a copy of the velocity vector first as we don’t want to reverse the object’s direction by accident.  Second, we normalize the vector.  This is because the magnitude of friction is not associated with how fast it is moving, and we want to start with a friction vector of magnitude 1 so that it can easily be scaled.</simpara>
<simpara>According to the formula, the magnitude is <emphasis role="strong"><phrase role="var">μ</phrase></emphasis> * <emphasis role="strong"><phrase role="var">N</phrase></emphasis>.   <emphasis role="strong"><phrase role="var">μ</phrase></emphasis> is the Greek letter Mu (pronounced “mew”), which is used here to describe the “coefficient of friction.”   The coefficient of friction establishes the strength of a friction force for a particular surface.  The higher it is, the stronger the friction; the lower, the weaker.   A block of ice, for example, will have a much lower coefficient of friction than, say, sandpaper.   Since we’re in a pretend Processing world, we can arbitrarily set the coefficient based on how much friction we want to simulate.</simpara>
<programlisting language="java" linenumbering="unnumbered">---
float c = 0.01;
---</programlisting>
<simpara>Now for the second part: <emphasis role="strong"><phrase role="var">N</phrase></emphasis>.  <emphasis role="strong"><phrase role="var">N</phrase></emphasis> refers to the “normal” force, the force perpendicular to the object’s motion along a surface.  Think of a vehicle driving along a road.   The vehicle pushes down against the road with gravity, and Newton’s third law tells us that the road in turn pushes back against the vehicle.  That’s the normal force.  The greater the gravitational force, the greater the normal force.   As we’ll see in the next section, gravity is associated with mass and so a lightweight sports car would experience less friction than a massive tractor trailer truck.   With the diagram above, however, where the object is moving along a surface at an angle, computing the normal force is a bit more complicated because it doesn’t point in the same direction as gravity.  We’ll need to know something about angles and trigonometry.</simpara>
<simpara>All of these specifics are important; however, in Processing, a “good enough” simulation can be achieved without them.  We can, for example, make friction work with the assumption that the normal force will always have a magnitude of 1.  When we get into trigonometry in the next chapter, we’ll remember to return to this question and make our friction example a bit more sophisticated.  Therefore:</simpara>
<programlisting language="java" linenumbering="unnumbered">---
float normal = 1;
---</programlisting>
<simpara>Now that we have both the magnitude and direction for friction, we can put it all together:</simpara>
<programlisting language="java" linenumbering="unnumbered">---
float c = 0.01;
float normal = 1;
// Let’s figure out the magnitude of friction
// (really just an arbitrary constant).
float frictionMag = c*normal;</programlisting>
<simpara>PVector friction = velocity.get();
friction.mult(-1);
friction.normalize();</simpara>
<simpara>friction.mult(frictionMag);
---</simpara>
<simpara>&#8230;and add it to our “forces” example, where many objects experience wind, gravity, and now friction:</simpara>
<simpara>====Example 2-1: Including friction</simpara>
<programlisting language="java" linenumbering="unnumbered">---
void draw() {
  background(255);</programlisting>
<literallayout class="monospaced">PVector wind = new PVector(0.001,0);
// We could scale by mass to be more accurate
PVector gravity = new PVector(0,0.1);</literallayout>
<literallayout class="monospaced">for (int i = 0; i &lt; movers.length; i++) {</literallayout>
<literallayout class="monospaced">*float c = 0.01;
PVector friction = movers[i].velocity.get();
friction.mult(-1);
friction.normalize();
friction.mult(c);</literallayout>
<literallayout class="monospaced">$$ Apply friction force vector to object
movers[i].applyForce(friction);*
movers[i].applyForce(wind);
movers[i].applyForce(gravity);</literallayout>
<literallayout class="monospaced">  movers[i].update();
  movers[i].display();
  movers[i].checkEdges();
}</literallayout>
<simpara>}
---</simpara>
<simpara>image:imgs/chapter02_13-01.png</simpara>
<simpara>image:imgs/chapter02_14-01.png</simpara>
<simpara><emphasis role="strong"><emphasis>no friction</emphasis></emphasis>                                 <emphasis role="strong"><emphasis>friction</emphasis></emphasis></simpara>
<simpara>Running this example, you’ll notice that the circles don’t even make it to the right side of the window.  Since friction continuously pushes against the object in the opposite direction of its movement, the object continuously slows down.  This can be a useful technique or a problem depending on the goals of your visualization.</simpara>
</example>
<formalpara><title>Exercise 2-4</title><para>Create pockets of friction in a Processing sketch so that objects only experience the friction when crossing over that area.    What if you vary the strength (friction coefficient) of each area?   What if you make some of them the opposite of friction—i.e., when you enter a given pocket you actually speed up instead of slowing down?</para></formalpara>
<informalexample>
<simpara>Friction also occurs when a body passes through a liquid or gas.  This force has many different names, all really meaning the same thing: viscous force, drag force, fluid resistance.  While the result is ultimately the same as our previous friction examples (the object slows down), the way in which we calculate a drag force will be slightly different.  Let’s look at the formula:</simpara>
<simpara>image:imgs/chapter02_15-01.png</simpara>
<simpara>image:imgs/chapter02_16-01.png</simpara>
<simpara>Now let’s break this down and see what we really need for an effective simulation in Processing, making ourselves a much simpler formula in the process.</simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><phrase role="var">F<subscript>d</subscript></phrase></emphasis> refers to “Drag Force”, the vector we ultimately want to compute and pass into our <emphasis role="strong"><phrase role="function">applyForce()</phrase></emphasis> function.
</simpara>
</listitem>
<listitem>
<simpara>
- 1/2 is a constant: -0.5!   This is fairly irrelevant in terms of our Processing world, as we will be making up values for other constants anyway.   However, the fact that it is negative is important, as it tells us that the force is in the opposite direction of velocity (just as with friction).
-￼image:imgs/chapter02_17-01.png is the Greek letter rho, and refers to the density of the liquid, something we don’t need to worry about.  We can simplify the problem and consider this to have a constant value of 1.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>[var]*v*</emphasis></emphasis> refers to the speed of the object moving.  OK, we’ve got this one!  The object’s speed is the magnitude of the velocity vector:  velocity.magnitude().  And <emphasis role="strong"><phrase role="var">v</phrase></emphasis><superscript>2</superscript> just means <emphasis role="strong"><phrase role="var">v</phrase></emphasis> squared or <emphasis role="strong"><phrase role="var">v</phrase></emphasis> * <emphasis role="strong"><phrase role="var">v</phrase></emphasis>.
</simpara>
</listitem>
<listitem>
<simpara>
A refers to the frontal area of the object that is pushing through the liquid (or gas).  An aerodynamic Lamborghini, for example, will experience less air resistance than a boxy Volvo.   Nevertheless, for a basic simulation, we can consider our object to be spherical and ignore this element.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><phrase role="var">C<subscript>d</subscript></phrase></emphasis> is the coefficient of drag, exactly the same as the coefficient of friction (<emphasis role="strong"><phrase role="var">μ</phrase></emphasis>).  This is a constant we’ll determine based on whether we want the drag force to be strong or weak.
</simpara>
</listitem>
<listitem>
<simpara>
image:imgs/chapter02_18-01.png Look familiar?  It should.  This refers to the velocity unit vector, i.e. velocity.normalize().  Just like with ￼friction, drag is a force that points in the opposite direction of velocity.
</simpara>
</listitem>
</itemizedlist>
<simpara>Now that we’ve analyzed each of these components and determined what we need for a simple simulation, we can reduce our formula to:</simpara>
<literallayout class="monospaced">*[var]*F~d~* = -1 * [var]*C~d~* * [var]*v*^2^ * image:imgs/chapter02_19-01.png￼</literallayout>
<simpara>or:</simpara>
<programlisting language="java" linenumbering="unnumbered">---
float c = 0.1;
float speed = v.mag();
// Part 1 of our formula (magnitude): Cd * v2
float dragMagnitude = c * speed * speed;
PVector drag = velocity.get();
// Part 2 of our formula (direction):
// -1 * image:imgs/chapter02_20-01.png￼
drag.mult(-1);
drag.normalize();
// Magnitude and direction together!
drag.mult(dragMagnitude);
---</programlisting>
<simpara>Let’s implement this force in our Mover example with one addition.   When we wrote our friction example, the force of friction was always present.  Whenever an object was moving, friction would slow it down.  Here, let’s introduce an element to the environment—a “liquid” that the Mover objects pass through.  The liquid object will be a rectangle and will know about its location, width, height, and “coefficient of drag”—i.e., is it easy for objects to move through it (like air) or difficult (like molasses)?  In addition, it should include a function to draw itself on the screen (and two more functions, which we’ll see in a moment.)</simpara>
<programlisting language="java" linenumbering="unnumbered">---
class Liquid {
  // The liquid object includes a variable defining
  // its coefficient of drag.
  float x,y,w,h;
  float c;</programlisting>
<literallayout class="monospaced">Liquid(float x_, float y_, float w_, float h_, float c_) {
  x = x_;
  y = y_;
  w = w_;
  h = h_;
  c = c_;
}</literallayout>
<literallayout class="monospaced">void display() {
  noStroke();
  fill(175);
  rect(x,y,w,h);
}</literallayout>
<simpara>}
---</simpara>
<simpara>The main program will now include a Liquid object reference as well as a line of code that initializes that object.</simpara>
<programlisting language="java" linenumbering="unnumbered">---
Liquid liquid;</programlisting>
<simpara>void setup() {
  liquid = new Liquid(0, height/2, width, height/2, 0.1);
  $$ Initialize a Liquid object.  Note how the coefficient value is low (0.1); otherwise, the object would come to a halt fairly quickly (which may someday be the effect you want).
}</simpara>
<simpara>Now comes an interesting question: how do we get the Mover object to talk to the Liquid object?  In other words, we want to execute the following:</simpara>
<simpara><emphasis>When a Mover passes through a Liquid it experiences a Drag force.</emphasis></simpara>
<simpara>or in object-oriented speak (assuming we are looping through an array of Mover objects with index i):</simpara>
<programlisting language="java" linenumbering="unnumbered">---
if (movers[i].isInside(liquid)) {
  // If a Mover is inside a Liquid, apply the drag force.
  movers[i].drag(liquid);
}
---</programlisting>
<simpara>The above code tells us that we need to add two functions to the Mover class: (1) a function that determines if a Mover object is inside the liquid, and (2) a function that computes and applies a drag force on the Mover object.</simpara>
<simpara>The first is easy; we can simply use a conditional statement to determine if the location vector rests inside the rectangle defined by the liquid.</simpara>
<programlisting language="java" linenumbering="unnumbered">---
boolean isInside(Liquid l) {
  if (location.x &gt; l.x &amp;&amp; location.x &lt; l.x + l.w &amp;&amp; location.y &gt; l.y &amp;&amp; location.y &lt; l.y + l.h) {
        // This conditional statement determines
    // if the PVector location is inside the rectangle
    // defined by the Liquid class.
    return true;
  } else {
    return false;
  }
}
---</programlisting>
<simpara>The <emphasis role="strong"><phrase role="function">drag()</phrase></emphasis> function is a bit more complicated; however, we’ve written the code for it already.  This is simply an implementation of our formula.  The drag force is equal to <emphasis>the coefficient of drag multiplied by the speed of the Mover squared in the opposite direction of velocity!</emphasis></simpara>
<simpara><emphasis role="strong">[var]*F<subscript>d</subscript></emphasis> = -1 * <emphasis role="strong"><phrase role="var">C<subscript>d</subscript></phrase></emphasis> * <emphasis role="strong"><phrase role="var">v</phrase></emphasis><superscript>2</superscript> * image:imgs/chapter02_21-01.png￼</simpara>
<programlisting language="java" linenumbering="unnumbered">---
 void drag(Liquid l) {</programlisting>
<literallayout class="monospaced">float speed = velocity.mag();
// The force’s magnitude: Cd * v2
float dragMagnitude = l.c * speed * speed;</literallayout>
<literallayout class="monospaced">PVector drag = velocity.get();
drag.mult(-1);
// The force’s direction: -1 * image:imgs/chapter02_22-01.png￼
drag.normalize();</literallayout>
<literallayout class="monospaced">// Finalize force: magnitude and direction -Cd * v2 * image:imgs/chapter02_23-01.png￼
drag.mult(dragMagnitude);</literallayout>
<literallayout class="monospaced">    // Apply the force
    applyForce(drag);
  }
---</literallayout>
<simpara>And with these two functions added to the Mover class, we’re ready to put it all together in the main tab:</simpara>
<simpara>====Example 2-2: Fluid Resistance</simpara>
<programlisting language="java" linenumbering="unnumbered">---
Mover[] movers = new Mover[100];</programlisting>
<simpara>Liquid liquid;</simpara>
<simpara>void setup() {
  size(360, 640);
  smooth();
  for (int i = 0; i &lt; movers.length; i++) {
    movers[i] = new Mover(random(0.1,5),0,0);
  }
  liquid = new Liquid(0, height/2, width, height/2, 0.1);
}</simpara>
<simpara>void draw() {
  background(255);</simpara>
<literallayout class="monospaced">liquid.display();</literallayout>
<literallayout class="monospaced">for (int i = 0; i &lt; movers.length; i++) {</literallayout>
<literallayout class="monospaced">if (movers[i].isInside(liquid)) {
  movers[i].drag(liquid);
}</literallayout>
<literallayout class="monospaced">// Note we are scaling gravity according to mass.
PVector gravity = new PVector(0, 0.1*movers[i].mass);
movers[i].applyForce(gravity);</literallayout>
<literallayout class="monospaced">    movers[i].update();
    movers[i].display();
    movers[i].checkEdges();
  }
}
---</literallayout>
<simpara>image:imgs/chapter02_24-01.png ￼ ￼ ￼</simpara>
<simpara>image:imgs/chapter02_25-01.png</simpara>
<simpara>image:imgs/chapter02_26-01.png</simpara>
<simpara>image:imgs/chapter02_27-01.png</simpara>
<simpara>Running the example, you should notice that we are simulating balls falling into water.  The objects only slow down when crossing in the gray area at the bottom of the window (representing the liquid).  You’ll also notice that the smaller objects slow down a great deal more than the larger objects.    Remember Newton’s second law?  <emphasis role="strong"><phrase role="var">A</phrase></emphasis> = <emphasis role="strong"><phrase role="var">F</phrase></emphasis> / <emphasis role="strong"><phrase role="var">M</phrase></emphasis>. Acceleration equals Force <emphasis role="strong"><emphasis>divided</emphasis></emphasis> by mass.  A massive object will accelerate less.  A smaller object will accelerate more.    In this case, the acceleration we’re talking about is the “slowing down” due to drag.  The smaller objects will slow down at a greater rate than the larger ones.</simpara>
</informalexample>
<formalpara><title>Exercise 2-5</title><para>Take a look at our formula for drag again.  <emphasis role="strong"><emphasis>DRAG FORCE = COEFFICIENT * SPEED * SPEED</emphasis></emphasis>.  The faster an object moves, the greater the drag force against it.  In fact, an object not moving in water experiences no drag at all.   Expand the example to drop the balls from different heights.  How does this affect the drag as they hit the water?</para></formalpara>
<informalexample>
</informalexample>
<formalpara><title>Exercise 2-6</title><para>The formula for drag also included surface area.  Can you create a simulation of boxes falling into water with a drag force dependent on the length of the side hitting the water?</para></formalpara>
<informalexample>
</informalexample>
<formalpara><title>Exercise 2-7</title><para>Fluid resistance does not work only opposite to the velocity vector, but also perpendicular to it.  This is known as “lift-induced drag” and will cause an airplane with an angled wing to rise in altitude.   Try creating a simulation of lift.</para></formalpara>
<informalexample>
<simpara>Probably the most famous force of all is gravity.   We humans on earth think of gravity as an apple hitting Isaac Newton on the head.    Gravity means that stuff falls down.  But this is only our experience of gravity.   In truth, just as the earth pulls the apple towards it due to a gravitational force, the apple pulls the earth as well.   The thing is, the earth is just so freaking big that it overwhelms all the other gravity interactions.  Every object with mass exerts a gravitational force on every other object.   And there is a formula for calculating the strengths of these forces:
￼
image:imgs/chapter02_28-01.png                  ￼</simpara>
<simpara>image:imgs/chapter02_29-01.png</simpara>
<simpara>Let’s examine this formula a bit more closely:</simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><phrase role="var">F</phrase></emphasis> refers to the gravitational force, the vector we ultimately want to compute and pass into our applyForce() function.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><phrase role="var">G</phrase></emphasis> is the “Universal Gravitational Constant” and in our world equals 6.67428 x 10-11 meters cubed per kilogram per second squared.   This is a pretty important number if your name is Isaac Newton or Albert Einstein.  It’s not an important number if you are a Processing programmer.  Again, it’s a constant that we can use to make the forces in our world weaker or stronger.  Just making it equal to one and ignoring it isn’t such a terrible choice either.
</simpara>
</listitem>
<listitem>
<simpara>
*[var]*m<subscript>1</subscript><emphasis role="strong"> and *[var]*m<subscript>2</subscript></emphasis> are the masses of objects 1 and 2.   As we saw with Newton’s second law (F = MA), mass is also something we could choose to ignore.  After all, shapes drawn on the screen don’t actually have a physical mass.  However, if we keep these values, we can create more interesting simulations where “bigger” objects exert a stronger gravitational force than smaller ones.
</simpara>
</listitem>
<listitem>
<simpara>
image:imgs/chapter02_30-01.png refers to the unit vector pointing from object 1 to object 2.  As we’ll see in a moment, we can compute this direction vector by subtracting the location of one object from the other.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><phrase role="var">r</phrase></emphasis><superscript>2</superscript> refers to the distance between the two objects squared.  Let’s take a moment to think about this a bit more.  With everything on the top of the formula—<emphasis>[var]<emphasis role="strong">G</emphasis>, <emphasis role="strong"><phrase role="var">m<subscript>1</subscript></phrase></emphasis>, <emphasis role="strong"><phrase role="var">m<subscript>2</subscript>*_—the bigger its value, the stronger the force.  Big mass, big force.  Big _[var]*G*</emphasis>, big force.  Now, when we divide by something we have the opposite.  The strength of the force is inversely proportional to the distance squared.  The *<emphasis>further</emphasis></phrase></emphasis> away an object is, the <emphasis role="strong"><emphasis>weaker</emphasis></emphasis> the force; the <emphasis role="strong"><emphasis>closer</emphasis></emphasis>, the <emphasis role="strong"><emphasis>stronger</emphasis></emphasis>.
</simpara>
</listitem>
</itemizedlist>
<simpara>Hopefully by now the formula makes some sense to us.  We’ve looked at a diagram and dissected the individual components of the formula.  Now it’s time to figure out how we translate the math into Processing code.  Let’s make the following assumptions.</simpara>
<simpara>We have two objects and:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
Each object has a location: <emphasis role="strong"><emphasis>PVector location1</emphasis></emphasis> and <emphasis role="strong"><emphasis>PVector location2</emphasis></emphasis>.
</simpara>
</listitem>
<listitem>
<simpara>
Each object has a mass: <emphasis role="strong"><emphasis>float mass1</emphasis></emphasis> and <emphasis role="strong"><emphasis>float mass2</emphasis></emphasis>.
</simpara>
</listitem>
<listitem>
<simpara>
There is a variable <emphasis role="strong"><emphasis>float G</emphasis></emphasis> for the universal gravitational constant.
</simpara>
</listitem>
</orderedlist>
<simpara>Given these assumptions, we want to compute <emphasis role="strong"><emphasis>PVector force</emphasis></emphasis>, the force of gravity.  We’ll do it in two parts.  First, we’ll compute the direction of the force (image:imgs/chapter02_31-01.png in the formula above).  Second, we’ll calculate the strength of the force according to the masses and distance.</simpara>
<simpara>Remember in Chapter 1, when we figured out how to have an object accelerate towards the mouse?</simpara>
<simpara>image:imgs/chapter02_32-01.png￼</simpara>
<simpara>A vector is the difference between two points. To make a vector that points from the circle to the mouse, we simply subtract one point from another:</simpara>
<programlisting language="java" linenumbering="unnumbered">---
PVector dir = PVector.sub(mouse,location);
---</programlisting>
<simpara>In our case, the direction of the attraction force that object 1 exerts on object 2 is equal to:</simpara>
<programlisting language="java" linenumbering="unnumbered">---
PVector dir = PVector.sub(location1,location2);
dir.normalize();
---</programlisting>
<simpara>Don’t forget that since we want a unit vector, a vector that tells us about direction only, we’ll need to <emphasis role="strong"><emphasis>normalize</emphasis></emphasis> the vector after subtracting the locations.</simpara>
<simpara>OK, we’ve got the direction of the force.  Now we just need to compute the magnitude and scale the vector accordingly.</simpara>
<programlisting language="java" linenumbering="unnumbered">---
float m = (G * mass1 * mass2) / (distance * distance);
dir.mult(m);
---</programlisting>
<simpara>The only problem is that we don’t know the distance.  <emphasis>[var]*G*</emphasis>, mass1, and mass2 were all givens, but we’ll need to actually compute distance before the above code will work.   Didn’t we just make a vector that points all the way from one location to another?   Wouldn’t the length of that vector be the distance between two objects?</simpara>
<simpara>image:imgs/chapter02_33-01.png</simpara>
<simpara>Well, if we add just one line of code and grab the magnitude of that vector before normalizing it, then we’ll have the distance.</simpara>
<programlisting language="java" linenumbering="unnumbered">---
// The vector that points from one object to another
PVector force = PVector.sub(location1,location2);</programlisting>
<simpara>float distance = force.magnitude();</simpara>
<simpara>float m = (G * mass1 * mass2) / (distance * distance);</simpara>
<simpara>force.normalize();
force.mult(m);
---</simpara>
<simpara>Note that I also renamed the PVector “dir” as “force.”   After all, when we’re finished with the calculations, the PVector we started with ends up being the actual force vector we wanted all along.</simpara>
<simpara>Now that we’ve worked out the math and the code for calculating an attractive force (emulating gravity), we need to turn our attention to applying this technique in the context of an actual Processing sketch.   In Example 2.x, you may recall how we created a simple Mover object—a class with PVector’s location, velocity, and acceleration as well as an <emphasis role="strong"><phrase role="function">applyForce()</phrase></emphasis>.  Let’s take this exact class and put it in a sketch with:</simpara>
<itemizedlist>
<listitem>
<simpara>
A single Mover object.
</simpara>
</listitem>
<listitem>
<simpara>
A single Attractor object (a new class that will have a fixed location).
</simpara>
</listitem>
</itemizedlist>
<simpara>The Mover object will experience a gravitational pull towards the Attractor object, as illustrated below.</simpara>
<simpara>image:imgs/chapter02_34-01.png</simpara>
<simpara>We can start by making the new Attractor class very simple—a location and a mass, along with a function to display itself (tying mass to size).</simpara>
<programlisting language="java" linenumbering="unnumbered">---
class Attractor {
  // Our Attractor is a simple object that doesn’t move.
  // We just need a mass and a location.
  float mass;
  PVector location;</programlisting>
<literallayout class="monospaced">Attractor() {
  location = new PVector(width/2,height/2);
  mass = 20;
}</literallayout>
<literallayout class="monospaced">  void display() {
    stroke(0);
    fill(175,200);
    ellipse(location.x,location.y,mass*2,mass*2);
  }
}
---</literallayout>
<simpara>And in our main program, we can add an instance of the Attractor class.</simpara>
<programlisting language="java" linenumbering="unnumbered">---
Mover m;
Attractor a;</programlisting>
<simpara>void setup() {
  size(200,200);
  m = new Mover();
  // Initialize Attractor object.
  a = new Attractor();
}</simpara>
<simpara>void draw() {
  background(255);</simpara>
<literallayout class="monospaced">// Display Attractor object.
a.display();</literallayout>
<literallayout class="monospaced">  m.update();
  m.display();
}
---</literallayout>
<simpara>This is a good structure: a main program with a Mover and Attractor object, and a class to handle the variables and behaviors of Movers and Attractors.   The last piece of the puzzle is how to get one object to attract the other.  How do we get these two objects to talk to each other?</simpara>
<simpara>There are a number of ways we could do this.  Here are just a few possibilities:</simpara>
<simpara>Table</simpara>
<informaltable
frame="all"
rowsep="1" colsep="1"
>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara>1. A function that receives both an <emphasis role="strong"><phrase role="class">Attractor</phrase></emphasis> and a <emphasis role="strong"><phrase role="class">Mover</phrase></emphasis>:</simpara></entry>
<entry align="left" valign="top"><simpara>attraction(a,m);</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>2. A function in the <emphasis role="strong"><phrase role="class">Attractor</phrase></emphasis> class that receives a <emphasis role="strong"><phrase role="class">Mover</phrase></emphasis>:</simpara></entry>
<entry align="left" valign="top"><simpara>a.attract(m);</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>3. A function in the <emphasis role="strong"><phrase role="class">Mover</phrase></emphasis> class that receives an <emphasis role="strong"><phrase role="class">Attractor</phrase></emphasis>:</simpara></entry>
<entry align="left" valign="top"><simpara>m.attractedTo(a);</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>4. A function in the <emphasis role="strong"><phrase role="class">Attractor</phrase></emphasis> class that receives a <emphasis role="strong"><phrase role="class">Mover</phrase></emphasis> and returns a <emphasis role="strong"><emphasis>PVector</emphasis></emphasis>, which is the attraction force.  That attraction force is then passed into the <emphasis role="strong"><phrase role="class">Mover*’s [function]*applyForce()</phrase></emphasis> function:</simpara></entry>
<entry align="left" valign="top"><simpara>PVector f = a.attract(m);
m.applyForce(f);</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>It’s good to look at a range of options for making objects talk to each other, and you could probably make arguments for each of the above possibilities.  I’d like to at least discard the first one, since an object-oriented approach is really a much better choice over an arbitrary function not tied to either the Mover or Attractor class.   Whether you pick (2) or (3) is the difference between saying “The attractor attracts the mover” or “The mover is attracted to the attractor.”  Number 4 is really my favorite, at least in terms of where we are in this book.  After all, we spent a lot of time working out the applyForce()function and I think our examples will be clearer if we continue with the same methodology.</simpara>
<simpara>In other words, where we once had:</simpara>
<programlisting language="java" linenumbering="unnumbered">---
// Made-up force
PVector f = new PVector(0.1,0);
m.applyForce(f);
---</programlisting>
<simpara>We now have:</simpara>
<programlisting language="java" linenumbering="unnumbered">---
// Attraction force between two objects
PVector f = a.attract(m);
m.applyForce(f);
---</programlisting>
<simpara>And so our draw() function can now be written as:</simpara>
<programlisting language="java" linenumbering="unnumbered">---
void draw() {
  background(255);</programlisting>
<literallayout class="monospaced">// Calculate attraction force and apply it.
*PVector f = a.attract(m);
m.applyForce(f);*</literallayout>
<literallayout class="monospaced">m.update();</literallayout>
<literallayout class="monospaced">a.display();
m.display();</literallayout>
<simpara>}
---</simpara>
<simpara>We’re almost there.  Since we decided to put the attract() function inside of the Attractor class, we’ll need to actually write that function.   The function needs to receive a Mover object and return a PVector, i.e.:</simpara>
<programlisting language="java" linenumbering="unnumbered">---
PVector attract(Mover m) {</programlisting>
<simpara>}
---</simpara>
<simpara>And what goes inside that function?  All of that nice math we worked out for gravitational attraction!</simpara>
<programlisting language="java" linenumbering="unnumbered">---
PVector attract(Mover m) {</programlisting>
<literallayout class="monospaced">// What’s the force’s direction?
PVector force = PVector.sub(location,m.location);
float distance = force.mag();
force.normalize();
// What’s the force’s magnitude?
float strength = (G * mass * m.mass) / (distance * distance);
force.mult(strength);</literallayout>
<literallayout class="monospaced">  // Return the force so that it can be applied!
  return force;
}
---</literallayout>
<simpara>And we’re done.  Sort of.  Almost.  There’s one small kink we need to work out.  Let’s look at the above code again.  See that symbol for divide, the slash?  Whenever we have one of these, we need to ask ourselves the question:  What would happen if  the distance happened to be a really, really small number or (even worse!) zero??!  Well, we know we can’t divide a number by zero, and if we were to divide a number by something like 0.0001, that is the equivalent of multiplying that number by 10,000!   Yes, this is the real-world formula for the strength of gravity, but we don’t live in the real world.  We live in the <emphasis>Processing</emphasis> world.   And in the Processing world, the Mover could end up being very, very close to the Attractor and the force could become so strong the Mover would just fly way off the screen.   And so with this formula, it’s good for us to be practical and constrain the range of what distance can actually be.   Maybe, no matter where the Mover actually is, we should never consider it less than 5 pixels or more than 25 pixels away from the Attractor.</simpara>
<programlisting language="java" linenumbering="unnumbered">---
  distance = constrain(distance,5,25);
---</programlisting>
<simpara>For the same reason we need to constrain the minimum distance, it’s useful for us to do the same with the maximum.  After all, if the Mover were to be, say, 500 pixels from the Attractor (not unreasonable), we’d be dividing the force by 250,000.  That force might end up being so weak that it’s almost as if we’re not applying it at all.</simpara>
<simpara>Now, it’s really up to you to decide what behaviors you want.  But in the case of, “I want reasonable-looking attraction that is never absurdly weak or strong,” then constraining the distance is a good technique.</simpara>
<simpara>Our Mover class hasn’t changed at all, so let’s just look at the main program and Attractor class as a whole, adding a variable “g” for the universal gravitational constant.  (On the web site, you’ll find that this example also has code that allows you to move the Attractor object with the mouse):</simpara>
<simpara>====Example 2-3: Attraction￼</simpara>
<simpara>image:imgs/chapter02_35-01.png</simpara>
<programlisting language="java" linenumbering="unnumbered">---
// A Mover and an Attractor
Mover m;
Attractor a;</programlisting>
<simpara>void setup() {
  size(200,200);
  m = new Mover();
  a = new Attractor();
}</simpara>
<simpara>void draw() {
  background(255);</simpara>
<literallayout class="monospaced">// Apply the attraction force from the Attractor on the Mover.
PVector force = a.attract(m);
m.applyForce(force);
m.update();</literallayout>
<literallayout class="monospaced">  a.display();
  m.display();
}</literallayout>
<simpara>class Attractor {
  float mass;
  PVector location;
  float G;</simpara>
<literallayout class="monospaced">Attractor() {
  location = new PVector(width/2,height/2);
  mass = 20;
  G = 0.4;
}</literallayout>
<literallayout class="monospaced">PVector attract(Mover m) {
  PVector force = PVector.sub(location,m.location);
  float distance = force.mag();
  // Remember, weneed to constrain the distance
  // so that our circle doesn’t spin out of control.
  distance = constrain(distance,5.0,25.0);
  force.normalize();
  float strength = (G * mass * m.mass) / (distance * distance);
  force.mult(strength);
  return force;
}</literallayout>
<literallayout class="monospaced">  void display() {
    stroke(0);
    fill(175,200);
    ellipse(location.x,location.y,mass*2,mass*2);
  }
}
---</literallayout>
<simpara>image:imgs/chapter02_36-01.png</simpara>
<simpara>And we could, of course, expand this example using an array to include many Mover objects, just as we did with friction and drag:</simpara>
<simpara>image:imgs/chapter02_37-01.png</simpara>
<programlisting language="java" linenumbering="unnumbered">---
Mover[] movers = new Mover[10];￼      $$ Now we have 10 Movers!</programlisting>
<simpara>Attractor a;</simpara>
<simpara>void setup() {
  size(400,400);
  for (int i = 0; i &lt; movers.length; i++) {
    // Each Mover is initialized randomly
    movers[i] = new Mover(random(0.1,2),random(width),random(height));
  }
  a = new Attractor();
}</simpara>
<simpara>void draw() {
  background(255);</simpara>
<literallayout class="monospaced">a.display();</literallayout>
<literallayout class="monospaced">for (int i = 0; i &lt; movers.length; i++) {
      // We calculate an attraction force for each Mover object.
  PVector force = a.attract(movers[i]);
  movers[i].applyForce(force);</literallayout>
<literallayout class="monospaced">  movers[i].update();
  movers[i].display();
}</literallayout>
<simpara>}
---</simpara>
</informalexample>
<formalpara><title>Exercise 2-8</title><para>In the example above, we have a system (i.e. array) of Mover objects and one Attractor object.  Build an example that has both systems of Movers and Attractors.  What if you make the Attractors invisible?  Can you create a pattern / design from the trails of objects moving around attractors?  (See the Metropop Denim project by Clayton Cubitt and Tom Carden: <ulink url="http://processing.org/exhibition/works/metropop/">http://processing.org/exhibition/works/metropop/</ulink>) for an example.)</para></formalpara>
<informalexample>
</informalexample>
<formalpara><title>Exercise 2-9</title><para>It’s worth noting that gravitational attraction is a model we can follow to develop our own forces.  This chapter isn’t suggesting that you should exclusively create sketches that use gravitational attraction.  Rather, you should be thinking creatively about how to design your own rules to drive the behavior of objects.  For example, what happens if you design a force that is weaker the closer it gets and stronger the farther it gets?  Or what if you design your attractor to attract far away objects, but repel close ones?</para></formalpara>
<informalexample>
<simpara>Hopefully, you found it helpful that we started with a simple scenario:  <emphasis>one object attracts another object</emphasis>, moving on to <emphasis>one object attracts many objects</emphasis>.  However, it’s likely that you are going to find yourself in a slightly more complex situation: <emphasis>many objects attract each other</emphasis>.  In other words, every object in a given system attracts every other object in that system (except for itself).</simpara>
<simpara>We’ve really done almost all of the work for this already.  Let’s consider a Processing sketch with an array of Mover objects:</simpara>
<programlisting language="java" linenumbering="unnumbered">---
Mover[] movers = new Mover[10];</programlisting>
<simpara>void setup() {
  size(400,400);
  for (int i = 0; i &lt; movers.length; i++) {
    movers[i] = new Mover(random(0.1,2),random(width),random(height));
  }
}</simpara>
<simpara>void draw() {
  background(255);
  for (int i = 0; i &lt; movers.length; i++) {
    movers[i].update();
    movers[i].display();
  }
}
---</simpara>
<simpara>The <emphasis role="strong"><phrase role="function">draw()</phrase></emphasis> function is where we need to work some magic.  Currently, we’re saying: “for every Mover i, update and display yourself.”  Now what we need to say is: “for every Mover i, be attracted to every other Mover j, and update and display yourself.”</simpara>
<simpara>To do this, we need to nest a second loop.</simpara>
<programlisting language="java" linenumbering="unnumbered">---
 for (int i = 0; i &lt; movers.length; i++) {
        $$ For every Mover, check every Mover!
    for (int j = 0; j &lt; movers.length; j++) {
      PVector force = movers[j].attract(movers[i]);
      movers[i].applyForce(force);
    }
    movers[i].update();
    movers[i].display();
  }
---</programlisting>
<simpara>In the previous example, we had an <emphasis role="strong"><phrase role="class">Attractor</phrase></emphasis> object with a function named <emphasis role="strong"><phrase role="function">attract()</phrase></emphasis>.  Now, since we have <emphasis role="strong"><emphasis>Movers</emphasis></emphasis> attracting <emphasis role="strong"><emphasis>Movers</emphasis></emphasis>, all we need to do is copy the <emphasis role="strong"><phrase role="function">attract()</phrase></emphasis> function into the <emphasis role="strong"><phrase role="class">Mover</phrase></emphasis> class.</simpara>
<programlisting language="java" linenumbering="unnumbered">---
class Mover {</programlisting>
<literallayout class="monospaced">// all the other stuff we had before plus. . .</literallayout>
<literallayout class="monospaced">// The Mover now knows how to attract another Mover.
PVector attract(Mover m) {
  PVector force = PVector.sub(location,m.location);
  float distance = force.mag();
  distance = constrain(distance,5.0,25.0);
  force.normalize();</literallayout>
<literallayout class="monospaced">    float strength = (G * mass * m.mass) / (distance * distance);
    force.mult(strength);
    return force;
  }
}
---</literallayout>
<simpara>Of course, there’s one small problem. When we are looking at every <emphasis role="strong">Mover [var]*i<emphasis role="strong"> and every *Mover [var]*j</emphasis>, are we OK with the times that [var]*i</emphasis> equals <emphasis role="strong"><phrase role="var">j</phrase></emphasis>?  For example, should <emphasis role="strong">Mover #3</emphasis> attract <emphasis role="strong">Mover #3</emphasis>?   The answer, of course, is no.   If there are five objects, we only want <emphasis role="strong">Mover #3</emphasis> to attract 0, 1, 2, and 4, skipping itself.   And so, we finish this example by adding a simple conditional statement to skip applying the force when i equals j.</simpara>
<simpara>====Example 2-4￼: Mutual Attraction</simpara>
<simpara>image:imgs/chapter02_38-01.png</simpara>
<programlisting language="java" linenumbering="unnumbered">---
Mover[] movers = new Mover[20];</programlisting>
<simpara>float g = 0.4;</simpara>
<simpara>void setup() {
  size(400,400);
  for (int i = 0; i &lt; movers.length; i++) {
    movers[i] = new Mover(random(0.1,2),random(width),random(height));
  }
}</simpara>
<simpara>void draw() {
  background(255);</simpara>
<literallayout class="monospaced">for (int i = 0; i &lt; movers.length; i++) {
  for (int j = 0; j &lt; movers.length; j++) {
    // Don’t attract yourself!
    if (i != j) {
      PVector force = movers[j].attract(movers[i]);
      movers[i].applyForce(force);
    }
  }
  movers[i].update();
  movers[i].display();
}</literallayout>
<simpara>}
---</simpara>
</informalexample>
<formalpara><title>Exercise 2-10</title><para>Change the attraction force in Example 2.x to a repulsion force.  Can you create an example where all of the Mover objects are attracted to the mouse, but repel each other?  Think about how you need to balance the relative strength of the forces and how to most effectively use distance in your force calculations.</para></formalpara>
<informalexample>
</informalexample>
<formalpara><title>The Ecosystem Project:</title><para>Step 2 Exercise:</para></formalpara>
<simpara>Incorporate the concept of forces into your ecosystem.   Try introducing other elements into the environment (food, a predator) that the creature interacts with.   Does the creature experience attraction or repulsion to things in its world?  Can you think more abstractly and design forces based on the creature’s desires or goals?</simpara>
<informalexample>
</informalexample>
</section>
</section>
</article>
